\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\date{}

\begin{document}

\hypertarget{introduction-to-datreat}{%
\section{Introduction to datreat}\label{introduction-to-datreat}}

\textbf{Content}

Introduction to datreat 1

Datreat Purpose and Philosophy 2

Data Structure 3

\begin{quote}
Files 3

Internal Representation 3
\end{quote}

Datreat Commands 4

\begin{quote}
Input/Output 4

Input of Data / Display of List of Loaded Data 4

Output of Data 5

Selecting dataset 6

Plotting 7

gp/gplot 7

Fitting 10

Setting-up Theories and Parameters 10

Theory Computations and Fittings 11

Saving Parameters and Fit Results 14

Output/Edit Theory Parameters 14

Write a List of Any Parameters/Variables 14

Cast Parameters into a Datreat Input File 14

Data Manipulation 15

General Purpose 15

SANS Related 16

Obsoletes 16
\end{quote}

makro Language 17

\begin{quote}
Call 17

Header and Parameters 17

Expressions 18

Loops 18

Commands that relate to the makro language 18

Predefined Variables/Function 19

Automatically Created Variables 19

Interaction with the system 20

History 20

Path 20

Active working directory 20

Collection of Standard and Example makros 20

cth obsolete but there 20
\end{quote}

Programming 21

\begin{quote}
Installation 21

Prerequesities 21

Compile: 21

Linking theories 22

Creating New Theories 22

Creating New Commands 23
\end{quote}

Available Theories 23

BSS-Data Converter 38

NEW DEVELOPMENT: Thinktank 39

\hypertarget{datreat-purpose-and-philosophy}{%
\section{Datreat Purpose and
Philosophy}\label{datreat-purpose-and-philosophy}}

Datreat is a command-based multi purpose system that allows to deal with
collections of (x,y)-data (data-records) each of which has an individual
block of parameters. Data may stem from any field ranging e.g. from SANS
diffraction results, NSE-S(Q,t) curves, magnetic field values along a
path, BSS-spectra etc.. Datreat allows to plot, manipulate and fit these
data-records. Theoretical models may be assembled from existing
``theories'' or new theories may be formulated (which, however, requires
some Fortran programming). Simultaneous fitting of collections of
data-records that are distinguished by one or several parameters is
supported as well as coupling of fit parameters.

Some automation of data-evaluation is possible with the help of
``makros''. These are files that contain a collection of genuine
commands including conditional and unconditional jumps that allow also
the construction of loops.

Interaction with the program is effected by commands. Each command line
consists of a \emph{\textbf{command-name}} and a number of
\emph{\textbf{items}} that are \emph{\textbf{separated by blanks}}.

\emph{\textbf{Command line item}}s may be \emph{\textbf{names}},
\emph{\textbf{numbers}} or \emph{\textbf{expressions}} that evaluate to
a number.

In general \emph{\textbf{expressions}} may be used at any place in
\emph{\textbf{command lines}} and \emph{\textbf{input files}} where a
\emph{\textbf{number}} would be appropriate.

The system classifies all items that start with one of the following
characters as \emph{\textbf{expressions}}:

\begin{quote}
\textbf{(+-.0123456789 }
\end{quote}

any item that would start with one of these characters and would not
lead to a valid \emph{\textbf{expression}} leads to an error.

Despite some preliminary mechanisms to specify a \emph{\textbf{path}}
the recommended use of Datreat is to call the program from the current
data-subdirectory and keep the specific makros and other auxiliary files
there too.

RB: But it is usefull to discriminate between raw data and evaluated
data plots ...

See \textbf{path} at the end

To \emph{\textbf{exit the program}}: \textbf{q}

\textbf{Hint1:} Running datreat from an Emacs-shell offers a number of
advantages, in particular the availability of command-line history (use
ALT-p, ALT-n) to retrieve previous/next command inputs. In addition all
editor functions are available on the whole output produced by the
current session.

A simple history (20 commands) exists. Accessible by ``\_xxx'' the last
command starting with xxx ist executed again.

\textbf{Hint2}: Command hierarchy: Commands are first used as datreat
commands than as makro name. After both failed (eg no makro with name
pwd) command is given to a new shell instance and executed. This means
you can use any shell command as you are used to it, as long as no
makros has the same name. (see history for a nice example how to use
this feature)

Here we will write always MAKRO with k because the makros are detected
by the German â€žmakro`` in the first line.

\textbf{Hint3:} If a makro ``\textbf{initdatr}'' exists within
datreat/makro or in your local path this will be executed right after
start of datreat. Its a normal makro and you can define your own path,
standard data treatment plotting ......... whatever you can imagine.

\hypertarget{data-structure}{%
\section{Data Structure}\label{data-structure}}

\hypertarget{files}{%
\subsubsection{Files}\label{files}}

\textbf{Data files:} contain a number of data records each of which
consists of a header, a parameter section and a list of x,y values with
an optional third column of y-errors.

\textbf{Theory definition file}: always has the value \textbf{lastth.}
To save previous versions copy it onto another name.

\textbf{Makro files}: contain a collection of command lines their names
follow the same rules as the data files. To qualify as a makro the name
must also be different from any genuine datreat-command and the first
line must start with the keyword: \textbf{makro}.

Shell commands are allowed. \textbf{Lines are limited to 1024
characters}.

\hypertarget{internal-representation}{%
\subsubsection{Internal Representation}\label{internal-representation}}

Data and theory definitions are stored internally (when loaded) in
common blocks with fixed (may be changed by recompiling the program with
other limits) maximum capacity.

The data on these structures are largely accessible by predefined system
functions.

\hypertarget{datreat-commands}{%
\section{Datreat Commands}\label{datreat-commands}}

\hypertarget{inputoutput}{%
\subsection{\texorpdfstring{\emph{Input/Output
}}{Input/Output }}\label{inputoutput}}

\hypertarget{input-of-data-display-of-list-of-loaded-data}{%
\subsubsection{Input of Data / Display of List of Loaded
Data}\label{input-of-data-display-of-list-of-loaded-data}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{in /input} & filename\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
reads data (x, y, y-error) from \textless{}filename\textgreater{}.

\textless{}filename\textgreater{} may not contain one of the fllowing
characters: `+-0123456789.(`. \textless{}filename\textgreater{} can be a
complete path prepended by variable \textless{}datapath\textgreater{}.
If \textless{}filename\textgreater{} starts with ./ or / (./path/name or
/path/name ) \textless{}datapath\textgreater{} is NOT prepended.

\textbf{Hint:} if data stem form a different computer system, make sure
that they do not contain tab's and extra CR-characters etc., these cause
occasionally observed errors during reading.

The last read data record is automatically selected. All previous
selections are removed.

\textbf{NEW Data format}

Simpler format rules: \textbf{parameters and comment ahead of Data }

parameter : any line starting with a name followed by numbers

(parameter name; first number is set as value; second number as parlev
(output control with plot)

data : line with minimum 2 values (x,y); 3\textsuperscript{rd} is used
as error; others are ignored

comment: everything not data or parameter; first comment line is stored;

other comment lines are ignored

ignored lines: start with ``\#'' as first character; ``values'' and
``paramete'' also ignored

new set: initiated by non Data after Data (parameters, comment or empty
line) or ``\#nxt''

\textbf{New }

\textbf{in} now reads also data in the `inx'-format (e.g. spectra vs.
meV or tof-channel from IN5). In order to reckognize this format the
files must have the extension `.inx'.

Further if reading inx data the option `GHz' may be specified. In that
case the meV scale of x is translated to circular frequency ${\omega}$ in GHz.
This option is ignored for tof-channel data.

Special functionality added to the input routines:

\begin{itemize}
\item
  variables \textbf{read1} and \textbf{readlast} are created/updated to
  give the frist and last addresses of the last read-in contents for
  automatic addressing purpose.
\item
  a variable \textbf{numor0} may be set prior to input of inx files, The
  automatically generated numor values then start at numor0+1.
\end{itemize}

\textbf{OLD} Data format for input files:

q= 0.161 dpeo25pmma75 no argon \textbf{:comment}

j04n019 ncounts vs omeg/Ghz 10308 \textbf{:name xname vs yname
\textless{}numor\textgreater{}}

parameter \textbf{:keyword=parameter}

normal 0.10000000E+01 \textbf{:f\_parnam \textless{}value\textgreater{}}

lambda 0.62710000E+01 \textbf{: â€ž â€ž â€ž}

q 0.16070952E+00

vzg\_velo 0.19110000E+05

temp 0.39580000E+03

chan\_v0 0.12700000E+03

d\_energ 0.17000000E+02

v\_5v 0.50000000E+01

: blank line

values \textbf{:keyword=values}

-0.25345777E+02 0.64695009E-02 0.17290469E-02 \textbf{:
\textless{}x\textgreater{} \textless{}y\textgreater{}
\textless{}y-error\textgreater{}}

-0.25129146E+02 0.63254744E-02 0.19072023E-02

......

0.24479254E+02 0.88531187E-02 0.18874913E-02

0.24695885E+02 0.78431373E-02 0.16721625E-02

: blank line

\#nxt \textbf{:keyword=\#nxt}

q= 0.002 dpeo25pmma75 no argon

j04n019 ncounts vs omeg/Ghz 10308

parameter

normal 0.10000000E+01 \textbf{0}

\ldots{}

v\_5v 0.50000000E+01

values

-0.26212299E+02 0.46082949E-02 0.46082952E-02

-0.25995668E+02 0.14817254E-02 0.49390846E-03

-0.25779038E+02 0.16228497E-02 0.72576046E-03

...

0.23829363E+02 0.74321813E-03 0.52553458E-03

0.24045993E+02 0.79744817E-03 0.56388101E-03

0.24262624E+02 0.78369906E-03 0.55415892E-03

\#eod \textbf{:keyword=\#eod}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{output-and-manipulating-of-data}{%
\subsubsection{Output and manipulating of
Data}\label{output-and-manipulating-of-data}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{save} & {[}\textless{}isel\textgreater{}{]} \textbf{to}
filename\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
saves data from selected respectively \textless{}isel\textgreater{}
internal record to \textless{}filename\textgreater{} . If
\textless{}filename\textgreater{} starts not with ``.'' or ``/''
savepath is prepended. Current \textbf{restriction}:
\textless{}filename\textgreater{} may not begin with one of the fllowing
characters: `+-0123456789(`.

\textbf{Hint:} behind the \textbf{data} the saved file will contain the
theory setting definition which was active at the time when the save
command was issued. Note that this will only be useful if save is
performed before a different theory setting which does not represent the
situation of the saved data is prepared!

\textbf{Hint2}: To restore the theory including parameters use :

\textgreater{} csplit \textless{}saved\_filename\textgreater{}
\%theory\% -f \textless{}theory\_filename\textgreater{}

resulting in a file \textless{} theory\_filename00 \textgreater{} which
you can cp to lastth, activate it by \textgreater{} acl and recalculate
theory by \textgreater{} thc\strut
\end{minipage}\tabularnewline
\textbf{msave} & filename\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
saves all selected data records to \textless{}filename\textgreater{}. If
\textless{}filename\textgreater{} starts not with ``.'' or ``/''
savepath is prepended. Current \textbf{restriction}:
\textless{}filename\textgreater{} may not begin with one of the fllowing
characters: `+-0123456789(`.

\textbf{Hint:} behind the \textbf{data} the saved file will contain the
theory setting definition which was active at the time when the save
command was issued. Note that this will only be useful if save is
performed before a different theory setting which does not represent the
situation of the saved data is prepared!

Use: get\_th \textless{}filename\textgreater{} to load the th-setting
only; in \textless{}filename\textgreater{} to load the data only; or the
macro inplus \textless{}filename\textgreater{} to load both.

NEW: virtually no length restriction for filenames.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{clip} & {[}{[}from \textless{}n1\textgreater{}{]} {[}to
\textless{}n2\textgreater{}{]}{]} {[}last \textless{}n\textgreater{}{]}
{[}errmax \textless{}val\textgreater{}{]} {[}rel{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
removes points from a loaded data record. Either by specifying the range
of data point numbers \textless{}n1\textgreater{}
..\textless{}n2\textgreater{}, resp. last \textless{}n\textgreater{} or
by setting a limit to the maximum error. \textbf{rel} modifies the error
condition to hold for relative errors.

\textbf{Note:} the action only affects the loaded data record and not
the data in the input file.

The userfunction indxval(ibuf,x) or intxval(ibuf,x) to extract point
numbers ni for x-values.\strut
\end{minipage}\tabularnewline
\textbf{rerange} & \textless{}x1\textgreater{}
\textless{}x2\textgreater{} {[}y{]}\tabularnewline
& creates a copy that contains only the points within the given range
\textless{}x1\textgreater{}\ldots{}\textless{}x2\textgreater{}; if the
option \textbf{y} is specified the range pertains the y axis, elswhere x
is considered.\tabularnewline
\textbf{copy} & {[}x1 \textless{}x1\textgreater{} x2
\textless{}x2\textgreater{}{]}\tabularnewline
& copy selected records (selection is transferred) to new records at the
end of the dir list. If x1 AND x2 are given only data from that interval
are copied.\tabularnewline
\textbf{sequence} &\tabularnewline
& replace x-values by sequence numbers, applies to all selected records
\tabularnewline
\textbf{swapxy} &\tabularnewline
& exchages x and y columns for all selected recors. Errors are
zeroed.\tabularnewline
\textbf{edit} & \textless{}n\textgreater{} {[}sc
\textless{}numor\textgreater{}{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
allows to edit data of data-record \textless{}n\textgreater{} or
data-record with \textless{}numor\textgreater{}. The contents is written
to a file \emph{\textbf{datbuf}} which is laded to an editor and reread
after the editor is left.

\textbf{Note:} the action only affects the loaded data record and not
the data in the input file\strut
\end{minipage}\tabularnewline
\textbf{putpar} & f\_parname
\textless{}value\textgreater{}\tabularnewline
& adds a parameter or changes a parameter value of the selected
data-record.\tabularnewline
\textbf{parlev} & f\_parname
\textless{}value\textgreater{}\tabularnewline
& modifies the display level (plot) of parameter (the higher, the more
supressed), display can be controlled with: plot parlev
\textless{}lev\textgreater{}\tabularnewline
\textbf{paraout} &\tabularnewline
& lists parameters of selcted record\tabularnewline
\textbf{numorchg} & \textless{}newnumor\textgreater{}\tabularnewline
& assigns new numor to first item in the selected list.\tabularnewline
\textbf{dir} & {[}\textbf{clength}
\textless{}displayed-comment-length\textgreater{}{]} {[}f\_parnam1{]}
{[}f\_parnam2{]}\ldots{}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
displays a list of the loaded data records. Selected records are marked
by a `\textbf{!}'.

The \textbf{clength} parameter allows to control the number of
characters that are dsplayed from a comment.

If f\_parname is given only data records that contain a parameter with
that name are listed and the parameter value is displayed. It is
possible to specify more than one f\_parname.\strut
\end{minipage}\tabularnewline
\textbf{z} &\tabularnewline
& zeroes data-record counter,. logically clears data-record
list.\tabularnewline
\bottomrule
\end{longtable}

\textbf{Associated variables: }

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{nbuf} & evaluates to the number of loaded items, i.e. points to
the end of the dir-list.\tabularnewline
\textbf{num(j)} & evaluates to the ``numor'' of the j-th loaded data
record.\tabularnewline
\textbf{nv(j)} & evaluates to the length (number of points) of the j-th
loaded data record.\tabularnewline
\textbf{xv(j,i)} & evaluates to the x-value of the i-th point of the
j-th loaded data record.\tabularnewline
\textbf{yv(j,i)} & evaluates to the y-value of the i-th point of the
j-th loaded data record.\tabularnewline
\textbf{ye(j,i)} & evaluates to the y-value error of the i-th point of
the j-th loaded data record.\tabularnewline
\textbf{sumx(j,i1,i2)} & evaluates to the sum of x-values from the i1-th
point to the i2-th point of the j-th loaded data record.\tabularnewline
\textbf{sumy(j,i1,i2)} & evaluates to the sum of y-values from the i1-th
point to the i2-th point of the j-th loaded data record.\tabularnewline
\textbf{indxval(j,x)} & evaluates indes number I of first point with
x(I) \textgreater{} x (integer value)\tabularnewline
\textbf{intxval(j,x)} & evaluates interpolated floating point
``address'' of x\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{selecting-dataset}{%
\subsubsection{Selecting dataset }\label{selecting-dataset}}

In general actions triggered by datreat commands are performed on all
data records that are selected.

In special cases a certain sequence of selections assigns data records
to different roles in command performance (see command descriptions).

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{sel} & \textless{}n1\textgreater{} \textless{}n2\textgreater{}
\ldots{}\ldots{}\ldots{}.\textless{}nx\textgreater{}
{[}add{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
selects exactly those data records with (internal) numbers
\textless{}n1\textgreater{}, \textless{}n2\textgreater{}
\ldots{}.\textless{}nx\textgreater{}.

The option \textbf{add} causes that the previous selctions are kept and
the new ones are added to the list.\strut
\end{minipage}\tabularnewline
\textbf{sel} & \textless{}n1\textgreater{} -\textless{}nx\textgreater{}
{[}add{]}\tabularnewline
& selects all data records with (internal) numbers
\textless{}n1\textgreater{}...\textless{}nx\textgreater{}\tabularnewline
\textbf{sel} & all f\_parnam \textless{}value\textgreater{} band
\textless{}range\textgreater{} {[}add{]}\tabularnewline
& selects all data records which have a parameter with name
\textbf{f\_parnam} which has a value within the range:
\textless{}value\textgreater{}Â±\textless{}range\textgreater{}.\tabularnewline
\textbf{sel} & next f\_parnam \textless{}value\textgreater{} band
\textless{}range\textgreater{} {[}add{]}\tabularnewline
& selects next data record (after actually selected) which hase a
parameter with name \textbf{f\_parnam} which has a value within the
range:
\textless{}value\textgreater{}Â±\textless{}range\textgreater{}.\tabularnewline
\textbf{sel} & {[}fits{]} {[}fit+{]}\tabularnewline
& selects fitted data, or fits associated to selected data
(fit+).\tabularnewline
\textbf{sel} & narrow f\_parnam \textless{}value\textgreater{} band
\textless{}range\textgreater{}\tabularnewline
& narrows selections.\tabularnewline
\textbf{sel} & exclude f\_parnam \textless{}value\textgreater{} band
\textless{}range\textgreater{}\tabularnewline
& exclude selections.\tabularnewline
\textbf{sel} & exclude numor mod
\textless{}n\textgreater{}\tabularnewline
& exclude records with run numbers mod(\#,n) = 0\tabularnewline
\textbf{sel} &\tabularnewline
& removes selections.\tabularnewline
\textbf{dsl} &\tabularnewline
& displays a list of the current selections. (see also
\textbf{dir})\tabularnewline
\textbf{purge} & \textless{}n1\textgreater{} \textless{}n2\textgreater{}
\ldots{}\ldots{}\ldots{}.\textless{}nx\textgreater{}
{[}all{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
removes data records \textless{}n1\textgreater{}
..\textless{}nx\textgreater{} or all data records from the dir-list.

\textbf{Note}: all selection will be removed!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Associated variables: }

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{sel} & evaluates to the last selected data record
number.\tabularnewline
\textbf{nsel} & evaluates to the number of selected data records (length
of selected list).\tabularnewline
\textbf{isel(i)} & evaluates to the data record number of the i-th
selected list item.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{plotting}{%
\subsection{\texorpdfstring{\emph{Plotting}}{Plotting}}\label{plotting}}

\textbf{Use xmgrace as plotting interface (gplot) solely}

\textbf{if the Grsoftware supporting the plot command is not installed !
}

\textbf{Try to use plot instead!}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\hypertarget{gplot}{%
\subsubsection{gplot}\label{gplot}}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\textless{}?/help\textgreater{}\textless{}nf\textgreater{}\textless{}fp\textgreater{}\textless{}ne\textgreater{}\textless{}nl\textgreater{}\textless{}cl\textgreater{}\textless{}cn\textgreater{}\textless{}na\textgreater{}

\textless{}k0\textgreater{}\textless{}com\textgreater{}\textless{}gr\textgreater{}\textless{}jp\textgreater{}\textless{}sv\textgreater{}\textless{}so\textgreater{}\textless{}cleanio\textgreater{}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
gplot,gp to plot selected files in connected xmgrace

gp plots into same grace until connection is closed

without open connection a new grace process is created

common parameter were extracted and a legend is shown build up from
uncommon params'

in grace: C-t write text

C-d delete text;

C-M moves objekt

C-L moves legend

all parameters were transferred to set comments in grace to identify
datasets

save your plots in the file menu as grace file (?.agr or ?.xgr ) if you
want to modify later

Print it in menu File/Print Setup (Device setup opens )

choose format and size ( press apply )

(for .eps choose Tight box in device options )

printed in menu point File/Print\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
Options:

help, h, ?

switches \textbf{on/off'}

fits, fi

fitpara, fp

error, er

legend, le

jointpar,jp

close, cl

clearplo,clear

autoscal, as\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
stored

for this help text

hide fits (but transfered )

write last fit parameters

no error bars (but transfered); can be changed in Set Appearance

hide legend; if parameters were appended they build up legend;

e.g. ``gplot le q'' hides parameters in legend except q values

write joint parameters'

close connection to grace after plotting; with ``save name cl'' in a
script a new plot is saved and then closed

gp starts always with an empty clean plot; works only for graph 0;
datasets 0-99 are deleted

autoscale switched off/on, default on\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
normal:

closenow, cn

kill, ki

command, com

graph, gr

start

save, sv

setoffset, so

cleanio\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
closes connection without plotting of new data

kills given sets in grace k,l deltes sets k l ; n -m kills from n to m;
-m kills from 0 to m

rest of input line as direct command to grace

see xmgrace help or grace files as example'

plot data in graph i, a new graph inside grace is build,' number i is
stored for next dataset

arrange them in EDIT/ARRANGE Graphs'

The rest of the line will be sent directly to grace'; used to customise
the startup behaviour of xmgrace. Its a semicolon separated list of
xmgrace commands e.g (see saved *.agr file )

\#\#\textgreater{} gp start title "NSE data";subtitle
"\textbackslash{}xt\textbackslash{}N is a fouriertime";xaxis label
"\textbackslash{}xt\textbackslash{}N / ns"'

save graceplot with following name (.agr is added)'; if name is ``on''
updated plots are saved always to ``lastgrace.agr''; without name its
saved to ``lastgrace.agr'' and switches save off.\\
offset for numbering new data, default 0

data with smaller numbers are preserved'

deletes iofile.tmpg?s? if exists'\strut
\end{minipage}\tabularnewline
& hints to grace\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
gplot com \textless{}grcom\textgreater{}\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
grcom is a direct command to grace

some usefull examples:

\emph{page size 400, 300} resizes page to 400, 300 pixels (try what you
like most)

\emph{xaxes scale Normal} scale set to lin

title ``this is the main title'' obvious

yaxis label "S(q,\textbackslash{}xt\textbackslash{}f\{\}) / S(q,0)"
obvious, see xmgrace help for text

\emph{yaxes scale Logarithmic} scale set to log

\emph{redraw} redraw plot needed sometimes do see the effect of
previous\\
commands\\
the full command in datreat is ``gp com redraw''

to install the .grace directory with default configuration files of
xmgrace copy the directory config.grace to your home directory as .grace

To change the default startup layout of your gracewindow open

.grace/templates/Default.agr

and save it again after you changed whatever you wanted.

\emph{To change the default behaviour look in grace.user to use
something like this input filter for .dat files. }

\emph{accept only lines starting with +,- or a number for .dat files}

\emph{DEFINE IFILTER "egrep '\^{}
*({[}+,-,0-9,\textbackslash{}.{]}\textbar{}\$)' \%s" PATTERN
"*.dat"}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
gplot start xxxx\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
xxx is the rest of the line after start. It is a semicolon separated
list of xmgrace commands like above and will be used for all of your
following new xmgrace windows in this session.

To have a permanent behaviouzr use initdatr initialization file in your
makro path.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\textbf{Plotting }

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{plot} & {[}xmin \textless{}xmin\textgreater{}{]} {[}xmax
\textless{}xmax\textgreater{}{]} {[}ymin
\textless{}ymin\textgreater{}{]} {[}ymax
\textless{}ymax\textgreater{}{]}\tabularnewline
& plots selected data records (including fit/thc results if present)
using the (optionally) specified range. Default is \emph{symbols} for
data and \emph{lines} for fit/thc results.\tabularnewline
\textbf{plot} & {[}\emph{option1}{]} \ldots{}\ldots{}.{[}
\emph{option\_n}{]}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
& \textbf{OPTIONS: }\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\textbf{log\_x :} log scale on x-axis (range given by xmin, xmax must be
\textgreater{} 0)

\textbf{lin\_x :} resets the default linear x-scaling

\textbf{log\_y :} log scale on y-axis (range given by ymin, ymax must be
\textgreater{} 0)

\textbf{lin\_y :} resets the default linear y-scaling

\textbf{symb \textless{}s1\textgreater{}
{[}\ldots{}\textless{}sn\textgreater{}{]}} : assigns symbols to plotted
curves

\textbf{icolo \textless{}c1\textgreater{}
{[}\ldots{}\textless{}cn\textgreater{}{]}:} assigns colors to plotted
curves

\textbf{errplo :} plot with error bars

\textbf{noerrplo :} plot without error bars (default)

\textbf{parplo :} plot with written parameters at the side (default)

\textbf{noparplo {[}f\_parnam1{]} {[}..{[}f\_parnam\_n{]}{]}}

\textbf{:} plot without parameters at the side except those listed:
{[}f\_parnam1\ldots{}..

\textbf{framx \textless{}fx\textgreater{} }

\textbf{framy \textless{}fy\textgreater{}}

\textbf{frlux \textless{}ux\textgreater{}}

\textbf{frluy \textless{}uz\textgreater{} :} changes size and shape of
plot area (axes) on the screen \textless{}fx\textgreater{}
\textless{}fy\textgreater{} dimension

\textbf{:} of plot window, \textless{}ux\textgreater{}
\textless{}uy\textgreater{} location of lower left (values in cm
relative A4)

\textbf{legsize \textless{}ls\textgreater{}}

\textbf{legx \textless{}lx\textgreater{}}

\textbf{legy \textless{}ly\textgreater{} :} text size and relative
location of block of written parameters.

\textbf{txsize \textless{}ts\textgreater{}}

\textbf{font \textless{}n\textgreater{} :} text size
\textless{}ts\textgreater{} (cm) and font (by number
\textless{}n\textgreater{})

\textbf{parlev \textless{}lev\textgreater{}} : level up to which
parameters are shown in plot (default 0), increase to see more

\textbf{text}

\textbf{notext :} allow or suppress text plotting completely.

\textbf{o \textless{}option\textgreater{} :} GR-software option
specifier string (graxs-subprogram). the format is e.g.

\textbf{o :} ox x=1 \{shows x-axes below your graph\}\{2 puts the axes
above\} and \{3 on both sides. -1/-2/-3 shows a grid\}\strut
\end{minipage}\tabularnewline
\textbf{p0} &\tabularnewline
& sets/changes options only without producing a plot.\tabularnewline
\textbf{tit} & \textless{}title-string\textgreater{}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
sets a title string that occurs as title on the plot.

tit 1 to 1 copies the input string,

title ``allows for strings and evaluated items'' x\strut
\end{minipage}\tabularnewline
\textbf{rename} & {[}\textbf{xaxis}
\textless{}new-string\textgreater{}{]} {[}\textbf{yaxis}
\textless{}new-string\textgreater{}{]} {[}\textbf{name}
\textless{}new-id\textgreater{}{]}\tabularnewline
& sets new names (labels) for xaxis, yaxis or ident of the selected data
record.\tabularnewline
\bottomrule
\end{longtable}

The plot command is based on the call of the FZJ/ZAM GR-software
package. It asks for an output device number to poduce the plot. For
X-terminals (and that is the standard now for all workplaces) the number
to be given is \textbf{211.}

\textbf{How to get a printed output?}

If the plot shall be printed or stored as eps-file, the output device
number is \textbf{62.} This causes the plot command to write a file
named \emph{gliXX.eps} with \emph{XX} the number of the plot invocation
during the current session. This file may be copied to another name
and/or printed using the UNIX \textbf{lpr} command.

\hypertarget{fitting}{%
\subsection{\texorpdfstring{\emph{Fitting}}{Fitting}}\label{fitting}}

\hypertarget{setting-up-theories-and-parameters}{%
\subsubsection{Setting-up Theories and
Parameters}\label{setting-up-theories-and-parameters}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{theos} & \textbf{\textless{}string\textgreater{}}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
lists names of all available theory types. (short: th )

\textless{}string \textgreater{} If string is given only theos starting
with string are listed.

The always available pseudo-theory \textbf{eval} is not quoted. It is
intended to allow for the ad-hoc fitting of simple expressions that have
to be enterd using the \textbf{yfitformel} command.\strut
\end{minipage}\tabularnewline
\textbf{ac} & theoryname {[}\textbf{multiply}{]} {[}\textbf{range}
\textless{}datparname\textgreater{} \textbf{min}
\textless{}p1\textgreater{} \textbf{max} \textless{}p2\textgreater{}
{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
activates one instance of theory theoryname which is appended to the
current list.

\textbf{Options:}

\textbf{multiply} if given the value from this theory instance is
multiplied to the result of the previous list,

\textbf{range} if given the name of the data parameter datparname and
min and max values are to be specified. The theory will only be
evaluated if the value of \textless{}datparname\textgreater{} as
parameter of a dataset under consideration is present and its value is
in the interval between \textless{}p1\textgreater{} and
\textless{}p2\textgreater{}.

\textbf{Hint:} the range option is intended to be used for fits of
datasets of a series with different values of an experimental parameter
(like an increasing Temperature stored as
\textless{}datparname\textgreater{}). A theory instance may be activated
for each dataset and assigned to it by appropriate specification of the
range interval. Those theory parameters that shall be common to the
whole data sets may be coupled (see below). Any individual scalings etc.
may simultaneously be effected by keeping the corresponding parameters
as individual fit parameters,\strut
\end{minipage}\tabularnewline
\textbf{acl} & activates last theory stored in file
lastth\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
\textbf{HINT:} To reuse a complete theory including parameters (how to
restore a theory setting from saved data see \textbf{save}) copy the
lastth to a different file name and copy it back to file name lastth if
needed like this:

\textgreater{}ac strexpo : activates theory strexpo

\textgreater{}emacs lastth : opens emacs to modify parameters close
it.or use \textbf{chgthpar}

\textgreater{}cp lastth lasth\_strexpo : copy to new filename (backup of
your settings)

to reuse it:

\textgreater{}cp lasth\_strexpo lastth

\textgreater{}acl\strut
\end{minipage}\tabularnewline
\textbf{gth} & gth \textless{}filename\textgreater{}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
synonym: \textbf{get\_th}

reads the automatically stored theory specification that is appended to
files written by the msave command (filename) and reactivates them.

The actual theory setting is replaced by that.\strut
\end{minipage}\tabularnewline
\textbf{dac} &\tabularnewline
& desactivates all theory instances. After \textbf{dac} the theory
definition is completely cleared.\tabularnewline
\textbf{al} &\tabularnewline
& lists current theory definition .on console and into file
\emph{\textbf{lastth}}.\tabularnewline
\textbf{chgthpar} & theoryname {[}\textless{}instance\textgreater{}{]}
t\_parname \textbf{par} \textless{}p1\textgreater{} \textbf{scale}
\textless{}s1\textgreater{}\tabularnewline
& sets parameter value \textless{}p1\textgreater{} and scale
\textless{}s1\textgreater{} for parameter \_t\_parname of the
\textless{}instance\textgreater{}-th instance of theory theoryname. If
scale \textless{}s1\textgreater{}=0 the parameter is fixed during fits,
otherwise \textless{}s1\textgreater{} should set to a value of the same
order of magnitude as the expected parameter value.\tabularnewline
\textbf{label} & theoryname {[}\textless{}instance\textgreater{}{]}
t\_parname label\tabularnewline
& assigns label label to parameter \_t\_parname of the
\textless{}instance\textgreater{}-th instance of theory theoryname. The
label may contain of a maximum of 4 characters. The labels are used to
establish parameter couplings between different theory
instances.\tabularnewline
\textbf{couple} & theoryname {[}\textless{}instance\textgreater{}{]}
t\_parname label \textless{}factor\textgreater{}\tabularnewline
& installs a coupling of a labelled parameter onto a parameter as quoted
in this command, The coupling factor is \textless{}factor\textgreater{}.
All changes with respect to the start values of the labelled parameter
are multiplied by facor \textless{}factor\textgreater{} and added to the
parameter quoted in this command. Coupling to several lablelled
parameters is possible. Parameters with couplings will not be fitted,
the corresponding scale \textbf{must be} \textbf{zero.}\tabularnewline
\textbf{yfitform\&} &
(xx*p(1)+p(2)*p(3)\ldots{}\ldots{}.)\tabularnewline
& definition of the special theory \textbf{eval.} xx means the actual
x-value, p(1)\ldots{}p(9) are parameters of the theory. Note the
necessary `\textbf{\&}' between yfitformel and the expression in
brackets. f\_parnams may be used.\tabularnewline
&\tabularnewline
\textbf{cth} & change theory parameter\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
Makro: allows editing of the complete theory definition list.

\textbf{Data format of theory list:}

theory zimm \textbf{1. instance of theory \emph{zimm}}

a1 intensit 0.9765E+00 0.1E+00 0.39E-02

eta\_solv 0.8220E-03 0.1E-02 0.18E-04

epsilon 0.1000E-06 0.0E+00 0.00E+00

temp 0.3000E+03 0.0E+00 0.00E+00

com\_diff 0.0000E+00 0.0E+00 0.00E+00

theory zimm \textbf{2. instance of theory \emph{zimm}}

intensit 0.9765E+00 0.0E+00 0.39E-02 a1 -1

eta\_solv 0.8220E-03 0.1E-02 0.18E-04

epsilon 0.1000E-06 0.0E+00 0.00E+00

temp 0.3000E+03 0.0E+00 0.00E+00

com\_diff 0.0000E+00 0.0E+00 0.00E+00

theory rouse range q min 0.1 max 0.3 \textbf{1. instance of theory
\emph{rouse}}

intensit 0.0000E+00 0.0E+00 0.00E+00

xi\_frict 0.1000E+09 0.0E+00 0.00E+00

b\_segmnt 0.5000E+01 0.0E+00 0.00E+00

epsilon 0.0000E+00 0.0E+00 0.00E+00

temp 0.3000E+03 0.0E+00 0.00E+00

com\_diff 0.0000E+00 0.0E+00 0.00E+00

q\_width 0.0000E+00 0.0E+00 0.00E+00

end

label par scale couplings

All numeric entries may also be expresssions which will be converted to
their numerical values upon reading. Remember: expressions must be given
in brackets () or begin by +.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{theory-computations-and-fittings}{%
\subsubsection{Theory Computations and
Fittings}\label{theory-computations-and-fittings}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{thc} & {[}\textbf{n} \textless{}num\textgreater{} \textbf{x1}
\textless{}x1\textgreater{} \textbf{x2} \textless{}x1\textgreater{}{]}
{[}\textbf{convolute} \textbf{xc1} \textless{}xc1\textgreater{}
\textbf{xc2} \textless{}xc2\textgreater{}{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
computes theory values for the selected data using the activated theory
list. Default is theory \emph{\textbf{evaluation at the location of data
points}} only. If \textbf{n} is specified the values are not computed at
the data point positions but on
\emph{\textbf{\textless{}num\textgreater{} equidistant points in the
interval between}} \textbf{x1} \textbf{and} \textbf{x2}. If the value
\emph{\textbf{\textless{}num\textgreater{}}} is \emph{\textbf{negative}}
the interval is divided in equidistant steps on a
\emph{\textbf{logarithmic scale}}.

The option convolute applies for SANS data only and requires special
parameters in the data sets (see SANS).

A first call of thc must contain x1 and x2 values.\strut
\end{minipage}\tabularnewline
\textbf{fit} & {[}\textbf{x1} \textless{}x1\textgreater{} \textbf{x2}
\textless{}x1\textgreater{} {]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
runs a fit of all selected data records with the list of activated
theories. By \textless{}x1\textgreater{} , \textless{}x2\textgreater{} a
(sub) interval for data comparison may be specified. If any parameters
are give go is needed to get an immediate start of fit, otherwise a
second call of fit without parameters starts the execution.

Further \textbf{options}:

writes one line into the opened parameter file according to the actual
selection and/or theory status.

fit {[}sc scan1 {[}scan2 ...{]}{]}

{[}x1 startvalue{]} {[}x2 endvalue{]} .. and other thc opts.

{[}auto{]}

{[}ngood est\_no. of valid digits in the theory{]}

{[}maxfn{]} max\_fun\_calls{]}

{[}relerr{]}

{[}abserr{]} (default)

{[}wrtfit{]} writes fitted curve data (x,y,yth) at each step onto file
\emph{\textbf{fitdat.tmp}}

{[}nowrtfit{]} (default)

{[}errors{]}

{[}map mgrid{]} {[}div ndiv{]}

{[}parwght{]} if nonzero the scale parameter deviation from their start
values is include into the error signal, this

may be used to restrict the parameter variation. Default is 0.

Wth the \textbf{fit} -command the parameters of the activated theories
are fitted to your selected data (more than one data-record may be
selected !) x1 specifies the lower x-value of the fit-interval, x2 the
upper value.

If \textbf{auto} is given x1 and x2 values are ignored and all data are
respected in the fit. the next time x1 or x2 is given again a
corresponding limit is again established. See also the command
\textbf{clip} .

With \textbf{maxfn} you can set the maximum number of function calls
that take place during the fit-procedure.

The \textbf{go}-option from previous version has beeen removed.

Convolution with a resolution function (SANS) may be performed; for
details see \textbf{fit} !

Another way to deal with resolution convolution is decribed in the
\textbf{BSS} part.

\textbf{map} option causes \textbf{fit} to writes files
\emph{\textbf{map.xy}} and \emph{\textbf{map.ssq}} that contain the
landscape of ssq vs paramaters (\textbf{max. no of free pars.=3}) The
parameters varied are those with nonzero fitscale. The stepwidth used is
fitscale/\textbf{div} (\textbf{div} may be given as parameter in the
command line, default is \textbf{20}). \textbf{map} must be followed by
the \emph{\textbf{number of grid points}} in each direction. Use
\emph{\textbf{ssq.gli}} to display the resulting files (2D).If map is
given \textbf{NO fitting} will be performed ! The comman dline must be
finished by the parameter: \textbf{go}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
Using \textbf{parameter values for output or in makros} is possible by
taking advantage of one of several mechanisms:

1: \textbf{fit} and \textbf{thc} add a number of paramters to the
resulting curve buffers these may be addressed in other functions or
viewed in the plot. These parameters describe the theory parameters and
errors.

In the moment we are still restricted to 8 characters for the names
therefore the theory parameters are coded as follows:

first 2 characters = first two charactres of theory name

3rd character = one digit (1..9) telling the number of the theory
instance in the activation list.

4..8 character = 1..5 charcater of the th-parameter name

The corresponding names for errors are build by putting 'e' in front of
the coded parameter name and truncating the result to 8 chars; those
parameters may be used in expressions.

See \textbf{plot noparplo} to get a plot with a non crowded parameter
part

2. The last instance of a parameter name is used to create a user
defined variable of that name and the value of the parameter. The
corresponding error has the same name with a trailing
`\emph{\textbf{e.}}'.

This mechanism is only viable if one or a few instances of different
theories are defined.

3. The internal vectors that hold the parameters are accessible via
\textbf{+th\_par(i,j)}, \textbf{+th\_err(i,j)} are evaluated to the
value of the i-th parameter (parameter-error) of the j-th instance of
any theory.\strut
\end{minipage}\tabularnewline
\textbf{serfit} & {[}\textbf{vs} \textless{}parnam\textgreater{}
{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
Using fit (parameters for fit can be given also) serfit performs a
serial fit over each single record of the selected list and creates
records containing the series

op parameters (x-values are taken form parameter
\textless{}parnam\textgreater{} of the selections.\strut
\end{minipage}\tabularnewline
\textbf{ga\_fit} & {[}\textbf{npop} \textless{}np\textgreater{}
\textbf{ngen} \textless{}ng\textgreater{} \textbf{mutation}
\textless{}mr\textgreater{} \textbf{bits} \textless{}nb\textgreater{}
\textbf{trace} \textless{}-2..2\textgreater{} {]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
simple genetic algorithm to find the optimum parameters.

The algorithm is useful to fit simple (fast to compute) functions with
many parameters.

The parameters are:

\textbf{npop} = size of `population' {[}100{]}

\textbf{ngen} = number of generations {[}100{]}

the total number of function calls is: \textbf{npop Ã— ngen}

\textbf{mutation} = mutation rate {[}0.001{]}

\textbf{bits} = resolution of parameter coding in bits {[}10{]}

\textbf{trace} = controls amount of output {[}-1{]}

The theory definition is the same as for `fit', however, the meaning of
the scale parameters

is slightly different, except for scale 0, which still means fixed
parameter.

For parameters to be fitted the scale parameter codes the range of
parameter search which is

\textbf{{[}startvalue-scale/2, startparameter+scale/2{]}}

After a \textbf{ga\_fit} a following call of \textbf{fit} is recommended
to increase the accuracy.\strut
\end{minipage}\tabularnewline
\textbf{th\_init} & not yet implemented\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
initialises the theories if they were changed during execution of
datreat

After changes in a theory or adding a new theory you have to compile it
and linkit by invoking ``make pur''in the main directory of datreat.
this will look for new theories and compile the shared library
libtheospur.so in datreat/lib which is used for the theories.

All this is done automatically with the comand \textbf{th\_make} below

compiles the theos library

afterwards you need to reinitialise the theories with
\textbf{th\_init}\strut
\end{minipage}\tabularnewline
&\tabularnewline
&\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{saving-parameters-and-fit-results}{%
\subsection{\texorpdfstring{\emph{Saving Parameters and Fit Results
}}{Saving Parameters and Fit Results }}\label{saving-parameters-and-fit-results}}

\hypertarget{outputedit-theory-parameters}{%
\subsubsection{Output/Edit Theory
Parameters}\label{outputedit-theory-parameters}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{al} &\tabularnewline
\textbf{activlst} &\tabularnewline
& lists current theory definition .on console and into file
\emph{\textbf{lastth}}.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{write-a-list-of-any-parametersvariables}{%
\paragraph{Write a List of Any
Parameters/Variables}\label{write-a-list-of-any-parametersvariables}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{print} & filename expr1 {[}expr2{]} {[}expr3{]}
\ldots{}\ldots{}\ldots{}\ldots{}..{[}expr9{]}\tabularnewline
& \textbf{appends} one line of numbers to file
\textless{}filename\textgreater{} expr1..9 denote expressions that
compute to a number. They may parameter names, user-defined variables,
automatic variables or expressions containing numbers and/or these
variables. \textbf{Remember:} only strings that start with one of the
following characters : `+-0123456789.(` will compute to a number, an
open bracket `(` requires a closing counterpart `)', blanks are not
allowed within an expression. Refer to section
\emph{\textbf{PredefinedVariables/Functions}} for a list of useful links
to internal information.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{cast-parameters-into-a-datreat-input-file}{%
\subsubsection{Cast Parameters into a Datreat Input
File}\label{cast-parameters-into-a-datreat-input-file}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{open} & filename parnam1 {[}no.theo1{]} parnam2
{[}no.theo2{]}\tabularnewline
& will prepare a file named file \textless{}filename\textgreater{} in
datreat readable input format for output. This file will be filled with
the values of the parameters with names \textless{}parnam1\textgreater{}
as x-values and \textless{}parnam2\textgreater{} as y-values. The
parameters may be taken from the parameter-block associated with the
currently selected file (1st file of selection list) or from the
parameters associated with the currently activated theory setting, in
the latter case it may be specified, by giving the number
\textless{}no.theo\textgreater{}, that the parameter is to be taken from
the \textless{}no.theo\textgreater{}-th instance of the theory's
parameter name in the activated list. Open write a
header.\tabularnewline
\textbf{write} &\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
writes one line into the opened parameter file according to the actual
selection and/or theory status.

\textbf{Tip:} to use any other values make them a parameter of the
selected file by the command putpar.\strut
\end{minipage}\tabularnewline
\textbf{close} &\tabularnewline
& closes the open parameter collecting file and writes \textbf{\#eod}
mark.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{data-manipulation}{%
\subsection{\texorpdfstring{\emph{Data
Manipulation}}{Data Manipulation}}\label{data-manipulation}}

\hypertarget{section}{%
\subsubsection{}\label{section}}

\hypertarget{general-purpose}{%
\subsubsection{General Purpose}\label{general-purpose}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{arit} & \textbf{f1} \textless{}f1\textgreater{} \textbf{f2}
\textless{}f2\textgreater{} \textbf{to} \textless{}numor\textgreater{}
{[}\textbf{mult}{]} {[}\textbf{div}{]}
{[}\textbf{norm}\textbar{}\textbf{nonorm}{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
linear combination of two selected data-records with factors
\textless{}f1\textgreater{} and \textless{}f2\textgreater{}, the result
gets the by \textbf{to} assigned \textless{}numor\textgreater{}. Default
is addition, the options \textbf{mult} or \textbf{div} select
multiplication or division of y-data.

norm or nonorm relate to monitor normalization, this is only effective
if the data-records contain a corresponding parameter
\emph{\textbf{monitor}}.\strut
\end{minipage}\tabularnewline
\textbf{addsels} &\tabularnewline
& adds all selected records and creates a new record with the sum that
inherits the parametyer of the middle record of the series (to be
improved). It assumes equal structure of the slected
records.\tabularnewline
\textbf{combine} & \textbf{raster} \textless{}xstart\textgreater{}
\textless{}dx\textgreater{} \textless{}n\textgreater{} \textbf{to}
\textless{}numor\textgreater{}
{[}\textbf{norm}\textbar{}\textbf{nonorm}{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
combines contents of selected data records and interpolates them to a
common grid (raster).

norm or nonorm relate to monitor normalization, this is only effective
if the data-records contain a corresponding parameter
\emph{\textbf{monitor}}.\strut
\end{minipage}\tabularnewline
\textbf{average} & \textbf{xcatch}
\textbf{\textless{}dx\textgreater{}}\tabularnewline
& error weighted average of different selected records, xcatch is the
relative distance below which the data points are combined. Typical use:
select all q \textless{}qx\textgreater{}; average\tabularnewline
\textbf{fun} & function
{[}\textless{}value\textgreater{}{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
applies a function to x or y-values f selected data records. See also:
\textbf{xformel} and \textbf{yformel} as alternatives.

function:

\textbf{x : x -\/-\/-\textgreater{} x }

\textbf{log(x) : ln(x) -\/-\/-\textgreater{} x }

\textbf{exp(x) : exp(x) -\/-\/-\textgreater{} x }

\textbf{x**2 : x\textsuperscript{2} -\/-\/-\textgreater{} x }

\textbf{x* \textless{}f1\textgreater{} : x* f1 -\/-\/-\textgreater{} x }

\textbf{x+ \textless{}s1\textgreater{} : x+ s1 -\/-\/-\textgreater{} x }

\textbf{sqrt(x) : sqrt(x)-\/-\/-\textgreater{} x }

\textbf{rouse : q\textsuperscript{2}*$\sqrt{wl^4 x)}$ -\/-\textgreater{} x}
\textbf{(q from parameter, wl4 from command or parameter)}
\textbf{Diffusion correction see y-values below.}

\textbf{zimm : (q**3*kT/(6*pi*eta)*x)**(2/3) -\/-\textgreater{} x (q,
temp, eta\_solv from parameter, or command)}

\textbf{y : y -\/-\/-\textgreater{} y }

\textbf{log(y) : ln(y) -\/-\/-\textgreater{} y }

\textbf{exp(y) : exp(y) -\/-\/-\textgreater{} y }

\textbf{y**2 : y\textsuperscript{2} -\/-\/-\textgreater{} y }

\textbf{y* {[}f1{]} : y* f1 -\/-\/-\textgreater{} y }

\textbf{y+ {[}s1{]} : y+ s1 -\/-\/-\textgreater{} y }

\textbf{sqrt(y) : sqrt(y)-\/-\/-\textgreater{} y }

\textbf{deff : y/x\textsuperscript{2} -\/-\/-\textgreater{} y}

\textbf{rouse: y*exp(diff*q\textsuperscript{2}t)} \textbf{y (q from
parameter, diff from parameter in units cm**2/s} \textbf{(default))}

\textbf{Diffusion correction is only performed if commond is}

\textbf{fun rouse usediff \textless{}diff\textgreater{} {[}unit
\textless{}fc\textgreater{}{]}}

\textbf{where \textless{}diff\textgreater{} is the parameter name which
holds the diffusion value and}

\textbf{unit is the conversion factor of the unit of diff to A**2/ns,
default is 10\textsuperscript{7}. If usediff is not given no
diff-scaling of y values is performed.}

with appropriate calculation of errors

The results are written to newly created data records.\strut
\end{minipage}\tabularnewline
\textbf{xformel} & \textbf{\&}(xx*3+q\ldots{}\ldots{}.)\tabularnewline
\textbf{yformel} &
\textbf{\&}(sin(yy)*xx\^{}3\ldots{}\ldots{}.)\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
allows to specify expression by which the x and y-values (denoted xx and
yy within the expressions) of the selected data record are transformed.
The action is initiated by the command funfun.

Note the semicolon ; which is necessary here. The expression is given
within brackets, no blanks.\strut
\end{minipage}\tabularnewline
\textbf{funfun} & {[}immediate{]} {[}op{]}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
treats selected data-records according to the x- and y formulae which
are either taken from internal storage as specified by the
\textbf{xformel} and \textbf{yformel} commands if the option immediate
is given \textbf{OR} are taken as consecutive lines (max length 132) in
the file \emph{\textbf{formdat}}.

If the option \textbf{op} is given the data transformation id performed
``on place'' otherwise new data records are created.

Errors are treated appropriately.\strut
\end{minipage}\tabularnewline
\textbf{fxy} & {[}op{]} \& x=(xx*3\ldots{}.)
y=(yy+4\ldots{}.)\tabularnewline
& treats the selected records by applying the x= and y= formulas, if
present x= must be given before y=. Otherwise like funfun, but all in
one command line\tabularnewline
\textbf{seterr} &\tabularnewline
& creates an error column for the selected data-records by using the
expression specified by the command \textbf{yformel}.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{section-1}{%
\subsubsection{}\label{section-1}}

\hypertarget{section-2}{%
\subsubsection{}\label{section-2}}

\hypertarget{section-3}{%
\subsubsection{}\label{section-3}}

\hypertarget{section-4}{%
\subsubsection{}\label{section-4}}

\hypertarget{sans-related}{%
\subsubsection{\texorpdfstring{\\
SANS Related}{ SANS Related}}\label{sans-related}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{invers} & {[}bkgr \textless{}b\textgreater{}{]}\tabularnewline
& creates a data-record with xx\textsuperscript{2} and
y1/(y-b).\tabularnewline
\textbf{mirror} & \textless{}k0\textgreater{}
\textless{}k1\textgreater{} \textless{}k2\textgreater{}\tabularnewline
& generates a mirror-image of a selected data-record \textbf{k0} is the
estimated x-center \textbf{k1} and k2 specify the range that shall be
used to determine the center.\tabularnewline
\textbf{qc} &\tabularnewline
& converts x-values (channels) of the first selected data-record to
q-values. For that purpose the data-record has to have the following
f\_parameters: xk0, lambda, detdis, bklen ; i.e. channel of zero angle,
wavelength, detector distance, size of one detector
channel.\tabularnewline
\textbf{spline} & {[}iequal \textless{}i\textgreater{}{]} {[}nneu
\textless{}n\textgreater{}{]} {[}auto\textbar{}noauto smpar
\textless{}s\textgreater{}{]}\tabularnewline
& spline interpolation of the fiirst selected data-record. \textbf{nneu}
specifies the number of points of the splined data. auto selects
automatic parameter determination, noauto allows to specify smpar
\textless{}s\textgreater{} to control the amount of
smoothing.\tabularnewline
\textbf{des} & {[}nneu \textless{}n\textgreater{}{]} {[}qmax
\textless{}qm\textgreater{}{]} {[}errabs \textless{}ea\textgreater{}{]}
{[}errrel \textless{}er\textgreater{}{]}\tabularnewline
& infinite slit height desmearing. \textbf{nneu} specifies the number of
points of the treated data. Needs spline immediately before beeing
called. Needs f\_parameter: delqv\tabularnewline
\textbf{mux/dmx} & trans \textless{}tr\textgreater{} thick
\textless{}t\textgreater{} xmax \textless{}xmax\textgreater{} nfft
\textless{}n\textgreater{}\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
SANS multiple scattering computation / removal.

c yi \textless{}-\/-\/- i0 * sigma(x) * {[}unit sample thickness:d{]} =

c lim{[}d-\/-\textgreater{}0{]} ( i-measured(x,d) / d )

c the output data on y will the be scaled such that they represent

c yo \textless{}-\/-\/- i0 * i-measured(x,d) / d (note: no limit !!)

c
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

c i.e. the scattering intensity including all orders of multiple

c elastic small angle scattering will be calculated for a sample

c of unit thickness assuming the same primary intensity factor,i0,

c as for the input data.

c
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

c input variables:

c t ....... : transmission reduction factor due to small angle sc.

c xmax .... : largest scattering angle (or q) to be considered

c dx ...... : increment of x

c nx ...... : no. of points to be generated

c nfft .... : fft no. of points (optimal choice nfft=2**m)

c output variables:

c x(1..nfft/2) : output x-values

c y(1..nfft/2) : output y-values

c
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{section-5}{%
\subsubsection{}\label{section-5}}

\hypertarget{section-6}{%
\subsubsection{}\label{section-6}}

\hypertarget{backscatteringspectrometer-related}{%
\subsubsection{\texorpdfstring{\\
Backscattering/Spectrometer
Related}{ Backscattering/Spectrometer Related}}\label{backscatteringspectrometer-related}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{uni\_ft} &\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
Fourier trans for of selected spectrum. If spectrum and resolution are
selected (observe sequence of selection!) then also the `deconvoluted'
time function is produced.

The results (forurier transforms of data and resolution as well as the
`deconvoluted' time function is found in newly created records at the
end of the list.

The algorithm is that from Reiner Zorn's uni\_ft program.

The energy units given as x-axis are opserved: micro-eV, meV, GHz, omega
( GHz)

(GHz means giga rad/s)\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{obsoletes}{%
\subsection{\texorpdfstring{\emph{Obsoletes}}{Obsoletes}}\label{obsoletes}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{out-gli} & \textless{}filename\textgreater{}\tabularnewline
& writes data in simple x y column form.\tabularnewline
\textbf{inscn} & \textless{}filename\textgreater{}\tabularnewline
&\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{makro-language}{%
\section{makro Language}\label{makro-language}}

\hypertarget{call}{%
\subsubsection{Call}\label{call}}

A makro is a file (name max. 8 characters) which contains a header line
and a collection of command lines.

The filename must be different from the names of genuine commands.

At call a number of values may be given after the name that replace the
parameter-variables in the makro.

I.e. call:

\textbf{makname 1.23 op3 (expression1) .xx.}

invokes a makro with name maknam the first parameter evaluates to
0.123000e+00 the second is a string op3 the third gets the value of
(expression1) and the last one is again a string xx. Also shell commands
are involved, so you can also change file names etc.

Nested calls up to a nesting level of 10 are supported. However, all
variables have global scope!

It is possible to use normal shell commands in a makro eg to copy a fit
result or rename a file.

To load a list of files with unknown filenames (perhaps in a makro to
load all b\_\_\_???? files inside a directory ( with a line ``q 0.05''
use grep ))

Some commands to generate this makro (do it inside of datreat):

echo makro \textgreater{} newmakro :writes newmakro with line ``makro''

ls b\_\_\_41* \textbar{} sed 's\#\^{}\#in \#'
\textgreater{}\textgreater{} newmakro :sed appends â€žin â€ž in front of
filenames

echo sel 1 2 3 4 select some data

echo gp \textgreater{} newmakro : gp will plot selected data

start it with newmakro

think about the possibilities

\hypertarget{header-and-parameters}{%
\subsubsection{Header and Parameters}\label{header-and-parameters}}

The first line of a makro must start with the keyword: \textbf{makro .}

Then a number of arguments \textbf{\_arg1\_} \ldots{}may follow which
generally give the heading line the following structure:

\textbf{makro \_a1\_ \_a2\_ \_this\_ \_another\_}

in the makro body the arguments are \emph{\textbf{string replaced}} at
any place where they occur by the values given when the makro is called.
Expressions are first evaluated.

\hypertarget{expressions}{%
\subsubsection{Expressions}\label{expressions}}

Expressions evaluate to a (real) number and may be used throughout
\emph{\textbf{in commands and input files}} wherever a number is
expected. The system identifies an expression by the occurrence of one
of the following characters at the beginning of a blank-separated item:

\textbf{+-.0123456789(}

they may contain the following binary operators:

\textbf{+ - * / \^{} }

they may use the \emph{\textbf{system specific, user-defined or
automatically defined variables and functions}} as well as the following
standard mathematical functions:

\textbf{sqrt(x),sin(x),cos(x),tan(x),asin(x),acos(x),atan(x),ln(x),exp(x),abs(x),int(x)}

Expression may \emph{\textbf{not contain any blanks}}, since these are
considered as item separators throughout the system.

\hypertarget{loops}{%
\subsubsection{Loops}\label{loops}}

Loops must be formulated explicitly using \textbf{if} and \textbf{goto}.

\hypertarget{commands-that-relate-to-the-makro-language}{%
\subsubsection{Commands that relate to the makro
language}\label{commands-that-relate-to-the-makro-language}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{set} & v\_name
\textless{}(value\textbar{}expression)\textgreater{}\tabularnewline
& creates uservariable v\_name with value or value of
expression\tabularnewline
\textbf{vars?} &\tabularnewline
& lists all defined variables and values\tabularnewline
\textbf{??} & (expression)\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
displays the value of an expression, internal parnames from datasets can
be used

(value from first of multiple selected sets used)

?? +q evaluates the internal data variable q to its value

expression to be evaluated are indicated by brackets () or +- or contain
+*/- like a+b*q

set q2 q\^{}2 to calculate the square of q and access it latter as
uservariable q2\strut
\end{minipage}\tabularnewline
\textbf{clr} & v\_name\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
removes a variable.

\textbf{Hint:} a variable of the same name will mask the visibility of
am f\_parameter. To access the f\_parameter the variable must be
cleared. Vice versa creation of a corresponding variable may
deliberately be used to perform this making.\strut
\end{minipage}\tabularnewline
\textbf{if} & (expression1)
\textbf{\textless{}}\textbar{}\textbf{\textgreater{}}\textbar{}\textbf{=}\textbar{}\textbf{\textless{}=}\textbar{}\textbf{\textgreater{}=}
(expression2) \textbf{then} cmd\textbar{}\textbf{goto} :l\tabularnewline
& realizes an if condition by comparing the values of two
expressions.\tabularnewline
\textbf{goto} & :label\tabularnewline
& jumps to label. The label has to start with a colon `\textbf{:}' and
must be the only item of a line.\tabularnewline
cms & \textless{}system\textasciitilde{}command\textgreater{}
\textbf{obsolete} non commands or makros used as shell
commands\tabularnewline
& transmits the given system command to the shell. All blanks within the
system command may be replaced by `\textbf{\textasciitilde{}}'. By using
this mechanism errors may be avoided that would occur if the command
contains items beginning with `+','-` or `.' which normally would be
considered as expressions to be evaluated by the datreat
input-communication module.\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{predefined-variablesfunction}{%
\subsubsection{Predefined
Variables/Function}\label{predefined-variablesfunction}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{nbuf} & evaluates to the number of loaded items, i.e. points to
the end of the dir-list.\tabularnewline
\textbf{num(j)} & evaluates to the ``numor'' of the j-th loaded data
record.\tabularnewline
\textbf{nv(j)} & evaluates to the length (number of points) of the j-th
loaded data record.\tabularnewline
\textbf{xv(i,j)} & evaluates to the x-value of the i-th point of the
j-th loaded data record.\tabularnewline
\textbf{yv(i,j)} & evaluates to the y-value of the i-th point of the
j-th loaded data record.\tabularnewline
\textbf{ye(i,j)} & evaluates to the y-value error of the i-th point of
the j-th loaded data record.\tabularnewline
\textbf{xx} & evaluates to the currently appropriate x(i,j)-value (in
xyformel expressions).\tabularnewline
\textbf{yy} & evaluates to the currently appropriate y(i,j)-value (in
xyformel expressions).\tabularnewline
\textbf{ye} & evaluates to the currently appropriate y(i,j)-error (in
xyformel expressions).\tabularnewline
\textbf{maxx / minx} & evaluates to the maximum/minimum (x) of the
current data-record.\tabularnewline
\textbf{maxy / miny} & evaluates to the maximum/minimum (y) of the
current data-record.\tabularnewline
\textbf{centerx} & evaluates the ``center-of-mass'' of the selected data
record using the data in the fit-range {[}x1,x2{]}\tabularnewline
\textbf{widthx} & evaluates the distribution rms-width of the selected
data record using the data in the fit-range {[}x1,x2{]}\tabularnewline
\textbf{sumx(j,i1,i2)} & evaluates to the sum of x-values from the i1-th
point to the i2-th point of the j-th loaded data record.\tabularnewline
\textbf{sumy(j,i1,i2)} & evaluates to the sum of y-values from the i1-th
point to the i2-th point of the j-th loaded data record.\tabularnewline
\textbf{sel} & evaluates to the last selected data record
number.\tabularnewline
\textbf{nsel} & evaluates to the number of selected data records (length
of selected list).\tabularnewline
\textbf{isel(i)} & evaluates to the data record number of the i-th
selected list item.\tabularnewline
\textbf{sc(i)} & evaluates to the data-record address (number in list)
for data with numor=i. (inverse of num(j))\tabularnewline
\textbf{th\_par(i,j)} & evaluates to the value of the i-th parameter of
the j-th activated theory instance.\tabularnewline
\textbf{th\_err(i,j)} & evaluates to the error of the i-th parameter of
the j-th activated theory instance.\tabularnewline
\textbf{f\_parnam(i)} & evaluates to the value of parameter f\_parnam of
the i-th data-record.\tabularnewline
\textbf{f\_parnam } & evaluates to the parameter of the currently
considered data record (e.g. in xyformel expressions)..\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{automatically-created-variables}{%
\subsubsection{Automatically Created
Variables}\label{automatically-created-variables}}

\textbf{Main}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{ssq0} & chi-squared from last fit / thc.\tabularnewline
\textbf{t\_parnam} & (fit) parameter of theory \textbf{only unique if
there is just one theory instance} with this parameter
name.\tabularnewline
\textbf{e.t\_parnam} & evaluates to the error of
t\_parnam.\tabularnewline
\bottomrule
\end{longtable}

\textbf{Theories} create a number of user-variables and/or
f\_parameters, see there to get the corresponding descriptions.

\hypertarget{interaction-with-the-system}{%
\subsection{\texorpdfstring{\emph{Interaction with the system
}}{Interaction with the system }}\label{interaction-with-the-system}}

\hypertarget{history}{%
\subsubsection{History}\label{history}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\textbf{history}

\textbf{hist }\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
shows history of last 20 commands

writes them to file history\strut
\end{minipage}\tabularnewline
``\_???'' underscore & if the command has an underscore as first
character the last command starting with the same characters is redone
immediately.\tabularnewline
hist clear & clears internal history list\tabularnewline
\begin{minipage}[t]{0.47\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[t]{0.47\columnwidth}\raggedright
to create a makro from history:

echo makro \textgreater{} newmakro : creates a file newmakro with first
line â€žmakro``

histo clear :clear history

.... : do something

histo : shows history and writes it without line numbers to file history

cat history \textgreater{}\textgreater{} newmakro :appends history to
newmakro

.....

newmakro : use newmakro whenever you need\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{path}{%
\subsubsection{Path}\label{path}}

You can give presets in the â€žinitdatr`` makro somewhere in your datreat
makro path.

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{path} & shows path definitions\tabularnewline
\textbf{macrpath} & \textless{}newpath\textgreater{} change to newpath
defailt ``./'' additional path to search fpr makros\tabularnewline
\textbf{datapath} & \textless{}newpath\textgreater{} change to newpath
defailt ``./'' path to search for input datafiles\tabularnewline
\textbf{savepath } & \textless{}newpath\textgreater{} change to newpath
defailt ``./'' path where something is stored\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{active-working-directory}{%
\subsubsection{Active working
directory}\label{active-working-directory}}

\begin{longtable}[]{@{}ll@{}}
\toprule
\endhead
\textbf{cd } & \textless{}path\textgreater{} changes active working
directory. ``..'' is working\tabularnewline
\textbf{sys} & a system command\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{collection-of-standard-and-example-makros}{%
\subsection{\texorpdfstring{\emph{Collection of Standard and Example
makros}}{Collection of Standard and Example makros}}\label{collection-of-standard-and-example-makros}}

\hypertarget{cth-obsolete-but-there}{%
\subsubsection{cth obsolete but there }\label{cth-obsolete-but-there}}

Editing of theory parameters:

\begin{quote}
\textbf{makro}

\textbf{al}

\textbf{cms emacs lastth}

\textbf{acl}
\end{quote}

\hypertarget{programming}{%
\section{Programming}\label{programming}}

\hypertarget{installation}{%
\subsection{\texorpdfstring{\emph{Installation}}{Installation}}\label{installation}}

\hypertarget{prerequesities}{%
\subsubsection{Prerequesities}\label{prerequesities}}

Intel Fortran Compiler above 8.0 (needed Fortran 90)

LAPACK -\/- Linear Algebra PACKage

from http://www.netlib.org/lapack/

BLAS (Basic Linear Algebra Subprograms)

from http://www.netlib.org/blas/

should be installed on your system

(if you have problems with blas (missing functions) ask your system
administrator to install from the original package.

In lapack is a subset of blas included but it is only a subset)

Graphical output

xmgrace should be installed

http://plasma-gate.weizmann.ac.il/Grace/

other libraries are included in datreat

\hypertarget{compile}{%
\subsubsection{Compile:}\label{compile}}

\begin{itemize}
\item
  Datreat is a local operating program -\textgreater{} userspace you
  dont need root for datreat itself.
\item
  uncompress the tar.gz or your source file
\item
  In datreat main directory you find the "Makefile", type in a shell\\
  \textgreater{}\textgreater{}make
\item
  If you have a \$HOME/bin directory a executable script will be placed
  there, which calls datreat from the correct place, if bin is in your
  PATH variable you can call it from everywhere..
\item
  Afterwards you can reduce the used space on disc with "make clean".\\
  To delete all compiled files use "make cleanall" This is necessary
  after release of a new version or if you have problems with changes of
  names
\item
  \textbf{Test:} After compile start with datreat\\
  change dir with "cd test"\\
  start macro "testmac" as example macro
\end{itemize}

\textbf{make} \textless{}Options\textgreater{}"

Options:" builds datreat

\#update show new/changed files on nse/local/datreat Source

\#do\_update synchronize local files with nse datreat only update of the
original files

clean deletes object files executables were not touched

cleanall deletes everything exept source, for a new start

cleanlibs cleans only lib libs (if compiler changed) or new theories
were installed/written

help shows this "

distribution make a tar.gz to distribute to others with pure source
files and documentation

\hypertarget{linking-theories}{%
\subsection{\texorpdfstring{\emph{Linking
theories}}{Linking theories}}\label{linking-theories}}

The theories section is or should be a \textbf{standalone library} which
can , in near future , be used without datreat. The corresponding theos
Makefile is within src/theos . theories are linked automatically with a
limitation to 80 theories. Please select your needed theories and move
the unneeded theories to another folder. The old version theories in f77
are still working.

Please use only free available non-commercial libraries.

\textbf{Naming convention} is:
th\_give\_a\_usefull\_descriptive\_name.f90

Additional helper function :
without\_a\_th\_in\_front\_and\_a\_descriptive\_name.f90

It is planned to make it possible to use also C instead of Fortran90.

Perhaps at some point we will use Python as command interpreter with the
old Fortran theories. But till now this is only my plan -\/-Ralf

\hypertarget{creating-new-theories}{%
\subsection{\texorpdfstring{\emph{Creating New
Theories}}{Creating New Theories}}\label{creating-new-theories}}

In utilities a tiny program: \textbf{th\_template\_generator} is
supplied (src/UTILITIES).

Using this the salient names parameters and variables can be entered and
converted to a fortran template that conatins all the theory framework.
Subroutines and more compuations can be included by editing.

The final theory shall be copied from out.f90 to
src/theos/th\_theoryname.f90 and activated by make.

Example

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#

th\_template\_generator \textless{} template1

will create out.f90 from

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

Input template1:

\#THEORY thtester

a test comment to check the th\_template generator

and another line for it.

With complicated formulae.

\#CITE

ref. Plisch und Plum in Grimms Maerchen

\#PARAMETERS (allow 8 chars for name, start only beyond 8 with default)

ampli ! prefactor

scope ! scope scope scope

knurrrer ! a knurrer

\#RECIN-PARAMETERS (allow 8 chars for name, start only beyond 8 with
default)

q 0.1 ! Q-VALUE

temp 300.0 ! Temperatur der Probe

\#RECOUT-PARAMETERS

qq ! square of q

\#VARIABLES

double precision :: tau

integer :: myint

\#IMPLEMENTATION

tau = x

qq = q

\#SUBROUTINES

function s2(q)

double precision :: s2, q

s2 = 1

end function s2

\#END

The created .f90 th\_template:

out.f90:

-\/-\/-\/-\/-\/-\/-\/-\/-

FUNCTION th\_thtester(x, pa, thnam, parnam, npar,ini, nopar
,params,napar,mbuf)

!================================================================================

! a test comment to check the th\_template generator and another line
for it. With complicated formulae.

! ref. Plisch und Plum in Grimms Maerchen

use theory\_description

implicit none

real :: th\_thtester

character(len=8) :: thnam, parnam (*)

real :: pa (*)

real :: x , xh

integer :: mbuf, nparx, ier, ini, npar, iadda

integer, intent(inout) :: nopar

character(len=80), intent(inout) :: napar(mbuf)

real, intent(inout) :: params(mbuf)

double precision, parameter :: Pi = 4*atan(1d0)

integer :: actual\_record\_address

! the internal parameter representation

double precision :: ampli ! prefactor

double precision :: scope ! scope scope scope

double precision :: knurrrer ! a knurrer

! the recin parameter representation

double precision :: q ! Q-VALUE

double precision :: temp ! Temperatur der Probe

! the reout parameter representation

double precision :: qq ! square of q

double precision :: tau

integer :: myint

!

! -\/-\/-\/-\/- initialisation -\/-\/-\/-\/-

IF (ini.eq.0) then

thnam = 'thtester'

nparx = 3

IF (npar.lt.nparx) then

WRITE (6,*)' theory: ',thnam,' no of parametrs=',nparx,' exceeds current
max. = ',npar

th\_thtester = 0

RETURN

ENDIF

npar = nparx

! \textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}
describe theory with
\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}

idesc = next\_th\_desc()

th\_identifier(idesc) = thnam

th\_explanation(idesc) = " a test comment to check the th\_template
generator and another line for it. With complicated formulae."

th\_citation(idesc) = " ref. Plisch und Plum in Grimms Maerchen"

! -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\textgreater{} set the
parameter names -\/-\/-\textgreater{}

parnam ( 1) = 'ampli ' ! prefactor

parnam ( 2) = 'scope ' ! scope scope scope

parnam ( 3) = 'knurrrer' ! a knurrer

! \textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}
describe parameters
\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}

th\_param\_desc( 1,idesc) = "prefactor" !//cr//parspace//\&

th\_param\_desc( 2,idesc) = "scope scope scope" !//cr//parspace//\&

th\_param\_desc( 3,idesc) = "a knurrer" !//cr//parspace//\&

! \textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}
describe record parameters used
\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}

th\_file\_param(:,idesc) = " "

th\_file\_param( 1,idesc) = "q \textgreater{} Q-VALUE"

th\_file\_param( 2,idesc) = "temp \textgreater{} Temperatur der Probe"

! \textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}
describe record parameters creaqted by this theory
\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}\textgreater{}

th\_out\_param(:,idesc) = " "

th\_out\_param( 1,idesc) = "qq \textgreater{} square of q"

!

th\_thtester = 0.0

RETURN

ENDIF

!

! -\/-\/-\/- transfer parameters -\/-\/-\/-\/-

ampli = pa( 1)

scope = pa( 2)

knurrrer = pa( 3)

! -\/-\/-\/- extract parameters that are contained in the present record
under consideration by fit or thc -\/-\/-

iadda = actual\_record\_address()

! \textgreater{}\textgreater{}\textgreater{} extract: Q-VALUE

xh = 0.1

call parget('q ',xh,iadda,ier)

q = xh

! \textgreater{}\textgreater{}\textgreater{} extract: Temperatur der
Probe

xh = 300.0

call parget('temp ',xh,iadda,ier)

temp = xh

!

!
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

! -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-
implementation
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

!
-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

!

tau = x

qq = q

th\_thtester = ! INSERT RESULTING VALUE OF TH EVALUATION HERE

! -\/-\/-\/- writing computed parameters to the record
\textgreater{}\textgreater{}\textgreater{}

call parset('qq ',sngl(qq),iadda,ier)

CONTAINS

! subroutines and functions entered here are private to this theory and
share its variables

function s2(q)

double precision :: s2, q

s2 = 1

end function s2

end function th\_thtester

\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#

\hypertarget{creating-new-commands}{%
\subsection{\texorpdfstring{\emph{Creating New
Commands}}{Creating New Commands}}\label{creating-new-commands}}

????? If you want??

\hypertarget{available-theories}{%
\section{Available Theories}\label{available-theories}}

Use theos

more is coming soon

OLD datreat help

***** datreat information *****

symbols:

\textless{},\textgreater{} are used to mark a datreat-command (usually
the short form)

{[},{]} mark optional parameters

commands available: \textless{}command/synonym/synonym..\textgreater{}

\textless{}activate/ac\textgreater{} : activates a theory

\textless{}aclast/acl\textgreater{} : reactivates the last theory used

\textless{}activlst/al\textgreater{} : lists active theories \& current
parameters

\textless{}chgthpar\textgreater{} : change single theory parameter value
or scale

\textless{}label\textgreater{} : supply a theory parameter with a label

\textless{}couple\textgreater{} : install a coupling of a

theory parameter with a label

\textless{}arit\textgreater{} : allows arithmetic operations on your
data

\textless{}combine\textgreater{} : interpolates and combines data from

several datasets onto one raster

\textless{}clearsel/cs\textgreater{} : clears list of selected
datarecords

\textless{}cms\textgreater{} : executes a cms command (xedit,list,...)

\textless{}desactiv/dac\textgreater{} : deactivates all theories

\textless{}dir\textgreater{} : lists all loaded and generated
datarecords

\textless{}dsl\textgreater{} : lists all selected datarecords

\textless{}edit\textgreater{} : allows editing of a specified datarecord

\textless{}clip\textgreater{} : remove points (by numer or error-limit)

\textless{}save\textgreater{} : allows saving of a specified datarecord

\textless{}msave\textgreater{} : multiple data-record save (all
selected+fits)

\textless{}fit\textgreater{} : starts a fit of the selected data with
the

activated theory

\textless{}yfitform\textgreater{} : enters a fitformula for eval-theory
!

\textless{}open\textgreater{} : opens a file for the collection of

parameters(fitparametres) vs parameters(f.

\textless{}write\textgreater{} : writes the actual parameter(fitp.) into

the opened file

\textless{}close\textgreater{} : close the opened parameter collection
file

\textless{}help/?\textgreater{} : gives infos

\textless{}input/in\textgreater{} : reads a datafile

\textless{}invers\textgreater{} : converts i vs q-data to i-1 vs q**2

\textless{}iout\textgreater{} : sets output-level

\textless{}mirror/m\textgreater{} : mirrors the data

\textless{}numorpls\textgreater{} : sets the increment of scan-numbers
when

the data is treated. (default 10000)

\textless{}plot/p\textgreater{} : plots selected datarecords

\textless{}plot0/p0\textgreater{} : allows to set plot-parameters. no
plot!

\textless{}purge\textgreater{} : erases specified datarecords from
buffer

\textless{}q-conv/qc\textgreater{} : converts channel-numbers to q

\textless{}fun\textgreater{} : treat x and/or y -values by some
functions

\textless{}funfun\textgreater{} : x-formula and y-formula from file
fromdat

\textless{}fft\textgreater{} : experimental small angle multiple scatt.

\textless{}quit/q\textgreater{} : leaves the program

\textless{}sel\textgreater{} : selects specified datarecords

\textless{}sym\textgreater{} : makes data symmetric

\textless{}spline\textgreater{} : generates spline coefficients smooth
data

\textless{}des\textgreater{} : infinte slit height desmearing

\textless{}thc\textgreater{} : computes data according to activated
theo-

ries (no fit !)

\textless{}theos\textgreater{} : lists all theories available

\textless{}title/tit\textgreater{} : defines a title for the plots

\textless{}rename\textgreater{} : renames axis of selected items

\textless{}putpar\textgreater{} : puts a parameter into the list of
selected

\textless{}zero/z\textgreater{} : clears databuffer

\textless{}set\textgreater{} : set/create a user-defined variable

\textless{}clr\textgreater{} : remove user-defined variables

\textless{}setdeg\textgreater{} : set angle-units to degree

\textless{}setrad\textgreater{} : set angle-units to rad

\textless{}??\textgreater{} : display the value of a formula

\textless{}if\textgreater{} : if-construct for makros

\textless{}goto\textgreater{} : goto construct for makros

\textless{}vars?\textgreater{} : display all userdefined variables

\textless{}ref\textgreater{} : reference to internal data.

adressing a specific datarecord:

there are two ways to access a specific set of data: either use the

linenumber of the databuffer-directory or use the 'scan'-code of your

data, which is defined in your datafile or generated by some operations

of the program. nearly all of the commands require the keyword 'sc',

when you want to use the scan-code.

makro-facilities: you can define a makro containing a series of com-

mands which may use parameters. it is possible

to call makros recursively!!

to generate a makro use the \textless{}cms\textgreater{} xedit-command.

the first line must be:

makro {[}par1{]} {[}par2{]} {[}...{]}

now you can simply type your commands - one per line!

to use the parameters simply type the parameter-name.

example: \textless{}plot\textgreater{} sc par1 xmax par2 ymax 60

!!!\textgreater{} makros allow for the use of a few basic like

programming features as set, if and goto.

any numerical parameters may be a formula.

to identify a parameter as number or formula

the parameterexpression has to begin with

one of the following characters: '(+-.0..9'.

there are two standard makros, which, of course, can

be altered to suit your purposes: doit fname scannr

and cth. the first makro requires a filename and its

scancode as inputs and will read the file, find the

mirror-axes, symmetrize and convert channel-numbers

to q. the second makro calls xedit with the last

activated theories and parameters. this allows easy

theory-parameter-changes.

*

? -\/-\/-\/-\/-\/-\/- general remarks -\/-\/-\/-\/-\/-\/-\/-

to execute datreat simply type : datreat

after a while you will see a list of all available theories and then

the request-prompt: '-\/-\/-\/-\/-\textgreater{}'. always when this
symbol appears, you

can type a command. datreat will try to execute the command or - if

there is no such command - it will look for a makro with that name.

if there is no command and no makro with that name, no action will

take place.

a command line has the following syntax:

\textless{}cmd\textgreater{} parname1 value1 {[}value2{]} {[}..{]}
{[}parname2{]} {[}value1{]} {[}...{]}

cmd is the command-name, parameters are adressed by names and

seperated with a blank. with certain parameters you can set more

than one value. these have to be seperated by blanks, too.

usually every parameter once defined is kept until it is explicitly

changed. one important exeption from this rule is the list of selec-

ted datarecords. \textless{}m\textgreater{},\textless{}sym\textgreater{}
and \textless{}qc\textgreater{} allow only one selected item. if

there is more than one in the list, only the first datarecord is used!

the maximum no of names and of numerical values that may be given at

once is 20, the maximum length of an input line is 80 characters. one

input line may contain several commands seperated by ';'.

once you activated a theory and fitted your data, the fit-curve will

automatically be plotted. you can recognize a fit-curve in the data-

buffer (use \textless{}dir\textgreater{} to see) by a negative
scan-number. if you don't want

the fit further displayed, use \textless{}purge\textgreater{} to erase
it.

-\/-\/-\/-\/-\/-\/- additional remarks -\/-\/-\/-\/-\/-\/-

new theoretical curves for fitting may be programmed by use of one of

the subroutines thx1 ... thxn as templates (near the end of the

listing). if you look at the predefined theories, you will immediately

see, what you have to do.

to save a generated datarecord, use the
\textless{}edit\textgreater{}-command. when you enter

the fullscreen-editor, simply type 'file file xxxx' into the command-

line, where xxxx is the name, you want to give your file.

*

*

* -\/-\/-\/-\/-\/-\/- detailed explanations -\/-\/-\/-\/-\/-\/-

ac \textless{}ac\textgreater{} theoryname {[}par1{]} {[}scale1{]}
{[}par2{]} {[}scale2{]} {[}...{]}

or \textless{}ac\textgreater{} theoryname parname par1 {[}scale1{]}
{[}parname...{]}

or \textless{}ac\textgreater{} theoryname multiply parname par1
{[}scale1{]} {[}parname...{]}

the theorynames can be listed with the
\textless{}al\textgreater{}-command.

the number of parameters to be passed depends on the number you

defined for this theory (see general remarks).

the scale is used in the fit-procedure. for sensible results it

should be ten to the power of the corresponding parameter.

you can activate more than one theory by calling
\textless{}ac\textgreater{} several

times. all activated theories will be added or multiplied

respectively. i.e. if the multiply flag is given the

corresponding theory result is multiplied with the

result from the preceeding theories (sum or product)

instead of beeing added.

acl \textless{}acl\textgreater{}

theories that were activated before are reactivated with the

parameters as stored in file lastth. this file is rewritten

every times when \textless{}al\textgreater{} (list activated theories)
is executed

(this takes also place during the fit-procedure). you can edit

file lastth using the \textless{}cms\textgreater{} x-command.

typing of multiply (blank separated) behind a theory name

flags this as multiplicative theory, the result of which

is multiplied with the result from the previous theories

to yield the new (intermediate) result.

the command sequence al, \textless{}edit\textgreater{}, acl is combined
in the

cth makro, which thereby provides a tool for easy change

of theory(fit)-parameters.

al \textless{}al\textgreater{}

all activated theories and their actual parameters are listed.

this command rewrites the file lastth.

chgthpar \textless{}chgthpar\textgreater{} theoryname {[}number{]}
parametername {[}par new\_value{]} {[}scale new\_value{]}

changes the parameter given by parametername in the specified theory to

a new value and/or the scale of the parameter.

par and scale may be specified both or individually.

If the theoryname is not unique (e.g. the same theory is active several
times)

the optional \textless{}number\textgreater{} specifies the (sequence)
number of it in the list of

activated theories.

label \textless{}label\textgreater{} theoryname {[}which occurence{]}
parametername label

supplies a theory parameter with a label. the label may contain

up to 4 characters, it may not be a number nor may its first

character be a number. the label may be referenced if linear

couplings of parameters are to be employed during a fit.

see command couple.

cth \textless{}cth\textgreater{}

is a standard makro to faciliate the changing of theory-

(fit) parameters. it loads the actual parameter set into

the editor, thereby allows for editing and rereads the

(changed) parameters after filing of the editor input.

couple \textless{}couple\textgreater{} theoryname {[}which occurence{]}
parametername label factor

installs a coupling of a labeled parameter onto a parameter

quoted in this command. labels may be assigned to parameters

by the label command. the whole procedure may also be done

by editing the fitparameter-file.

see command label.

arit \textless{}arit\textgreater{} {[}normflag{]} {[}typ{]} {[}sc scan1
{[}scan2 ...{]}{]} {[}f1 factor1{]}

{[}f2 factor2{]} {[}to scan{]}

this command requires two selected scans; these can be selected

in the command with the sc-parameter.

If sc is not give arit expects two curves to be selected,

they are used as source in the seqence they were selected.

normflag must have one of

the values 'norm' or 'nonorm' - if not specified, norm is de-

faulted.

typ may be div or mult (if not give add is assumed)

the command performs arithmetic operations with your data:

factor1 * scan1-data + factor2 * scan2-data is written into

the destination-scan datarecord. if not specified by to, the

destination is defaulted.

the norm-option normalises by the monitor-parameter given in

your data-file. if this parameter is not specified, the program

will give a message.

errors are preserved

combine \textless{}combine\textgreater{} {[}sc scan1 {[}scan2 ...{]}{]}
{[}raster xstart dx n{]}

{[}to scan{]}

this command requires two or more selected scans;

these may be selected in the command with the sc-parameter.

the data are collected on a new scan, which has x-values

that are created by the raster directive. y-values are

generated by interpolation from the input data sets.

if the input data sets are provided with a monitor

parameter, data and monitor values are summed for each

overlapping channel. finally all data are normalized

to the summed monitor values. if no monitor-data are

given, 1 is assumed. errors are evaluated using

the 1/sqrt(n) ansatz. x-points that are not present

in the set of input points are set to zero.

cs \textless{}cs\textgreater{}

this command clears the list of selected data-records.

cms \textless{}cms\textgreater{} cms-command

with \textless{}cms\textgreater{} it is possible to use most of the
cms-commands,

especially the xeditor. when a cms-command is executed, it will

return to the program.

dac \textless{}dac\textgreater{} {[}number1{]} {[}number2 ...{]}

the theories are deactivated according to their number of acti-

vation. if you use \textless{}dac\textgreater{} without a parameter, all
theories are

deactivated.

you can reactivate these theories by \textless{}acl\textgreater{}.

dir \textless{}dir\textgreater{} {[}\textless{}clength\textgreater{}
value{]}

this command shows you all the datarecords presently loaded. it

is recommended to press the pa2-button before executing this

command.

The optional parameter \textless{}clength\textgreater{} followed by a
value=1..80 set

the number of characters of the comment to be displayed.

dsl \textless{}dsl\textgreater{}

lists all selected datarecords.

edit \textless{}edit\textgreater{} {[}number{]} {[}sc scan{]}

with \textless{}edit\textgreater{} you can change the datarecords that
are loaded or

generated by the program. this command will call the xeditor.

\textless{}edit\textgreater{} also gives you the possibility to save
these records on

your disk: you only have to specifiy a filename when leaving the

xeditor by file or ffile. if you only type file, your datarecord

is stored in file datbuf and your original file (if existing)

will not be affected.

clip \textless{}clip\textgreater{} {[}{[}\textless{}from\textgreater{}
n1{]} {[}\textless{}to\textgreater{} n2{]}{]}
{[}\textless{}last\textgreater{} n{]} {[}\textless{}errmax\textgreater{}
val{]} {[}\textless{}rel\textgreater{}{]}

removes points from n1 to n2 or the last n points or all

points with error \textgreater{} errmax wit option rel relative error is
checked

save \textless{}save\textgreater{} to filename SEE ALSO: msave

\textless{}save\textgreater{} dirnum to filename

\textless{}save\textgreater{} n name to filename

\textless{}save\textgreater{} sc numor to filename

\textless{}save\textgreater{}

store a datarecord on disk permanently with the name :

file filename a. if no item is specified the first datarecord

in the selection table will be saved. by giving dirnum the

dirnum-th record as shown in the dir-list may be saved.

by specifying n name a file with the internal name
\textless{}name\textgreater{} will

be save and by sc \textless{}numor\textgreater{} a file with the
corresponding numor

will be saved. if no destination \textless{}filename\textgreater{} is
given the data

will be saved onto file lastsave.

msave \textless{}msave\textgreater{} filename

store a datarecords on disk permanently with the name :

file filename a.

Records that are selected are stored (associated fit

results are also stored).

\textless{}open\textgreater{} \textless{}open\textgreater{} filename
parnam1 {[}no.theo1{]} parnam2 {[}no.theo2{]}

will prepare a file named file \textless{}filename\textgreater{} a for
output.

this file will be filled with the values of the parameters

with names \textless{}parnam1\textgreater{} as x-values and
\textless{}parnam2\textgreater{} as y-values.

the parameters may be taken from the parameter-block associated

with the currently selected file (1st file of selection list)

or from the parameters associated with the currently activated

theory setting, in the latter case it may be specified

by giving \textless{}no.theo\textgreater{} that the parameter is to be
taken from

the \textless{}no.theo\textgreater{}-th theory that is activated.

\textless{}write\textgreater{} \textless{}write\textgreater{}

write one line into the opened parameter file according to the

actual selection and/or theory status.

\textless{}close\textgreater{} \textless{}close\textgreater{}

close the open parameter collecting file.

\textless{}fun\textgreater{} \textless{}fun\textgreater{} optionx
optiony

treat all selected files by applying some functions to the x

and/or y-values.

option : op or np : item -\/-\/-\textgreater{} item or item
-\/-\/-\textgreater{} new item

optionx: x : x -\/-\/-\textgreater{} x

log(x) : ln(x) -\/-\/-\textgreater{} x

exp(x) : exp(x) -\/-\/-\textgreater{} x

x**2 : x**2 -\/-\/-\textgreater{} x

x* {[}f1{]} : x* f1 -\/-\/-\textgreater{} x

x+ {[}s1{]} : x+ s1 -\/-\/-\textgreater{} x

sqrt(x) : sqrt(x)-\/-\/-\textgreater{} x

rouse : q**2*sqrt(wl4*x) -\/-\textgreater{} x (q from parameter, wl4
from command or parameter)

zimm : (q**3*kT/(6*pi*eta)*x)**(2/3) -\/-\textgreater{} x (q, temp,
eta\_solv from parameter)

(optional eta from command)

optionx: y : y -\/-\/-\textgreater{} y

log(y) : ln(y) -\/-\/-\textgreater{} y

exp(y) : exp(y) -\/-\/-\textgreater{} y

y**2 : y**2 -\/-\/-\textgreater{} y

y* {[}f1{]} : y* f1 -\/-\/-\textgreater{} y

y+ {[}s1{]} : y+ s1 -\/-\/-\textgreater{} y

sqrt(y) : sqrt(y)-\/-\/-\textgreater{} y

deff : y/(x**2) -\textgreater{} y

with appropriate errors

funfun x-values and y-values of all selected items are treated

by the formula lines that are given in file formdat a

as first and second line. the lines may not contain

any blanks within the formula. they may be written

as usual formulas, the x-values are to be referred

by xx, the y-values by yy.

exponentiation is indicated by \^{} eg. xx\^{}2, xx may

not be negative!

log is ln.

functions available: sin,cos,tan,asin,acos,atan,ln,exp,

sqrt,int,abs

the trig. function operate with rad or degree, which may

be switched by the setrad or setdeg command.

the output may be reduced by iout -5 .

fit \textless{}fit\textgreater{} {[}sc scan1 {[}scan2 ...{]}{]}

{[}x1 startvalue{]} {[}x2 endvalue{]} .. and other thc opts.

{[}auto{]}

{[}maxit max.\_number\_of\_iterations{]}

{[}ngood est\_no. of valid digits in the theory{]}

{[}maxstep max.\_step\_between\_to\_values{]}

{[}trustreg trustregion{]}

{[}maxfn max\_fun\_calls{]}

{[}relerr{]}

{[}abserr{]} (default)

{[}wrtfit{]}

{[}nowrtfit{]} (default)

{[}errors{]}

{[}map mgrid{]} {[}div ndiv{]} go

{[}go{]}

with the \textless{}fit\textgreater{}-command the parameters of the
activated theories

are fitted to your selected data (more than one data-record may

be selected !)

x1 specifies the lower x-value of the fit-intervall, x2 the

upper value.

if auto is given x1 and x2 values are ignored and all data are

respected in the fit. the next time x1 or x2 is given again

a corresponding limit is again established.

with maxfn you can set the maximum number of function calls that

take place during the fit-procedure.

the (volatile) errors option causes the computation of

statictical errors for the fit-parameters, provided

errors for the data are given. the errors option must

be combined with the go option.

the go-option must be explicitely stated every time the
\textless{}fit\textgreater{}-

command is used. if not given, \textless{}fit\textgreater{} will only
find the para-

meters for the activated theory. the curve-fitting can then be

done by once more typing \textless{}fit\textgreater{} without any
parameters.

convolution with a resolution function may be performed.

for details see thc !

fit and thc add a number of paramters to the resulting curve buffers

these may be addressed in other functions or viewed in the plot.

These parameters describe the theory parameters and errors.

In the moment we are still restricted to 8 characters for the

names therefore the theory parameters are coded as follows:

first 2 characters = first two charactres of theory name

3rd character = one digit (1..9) telling the number of the

theory in the activation list.

4..8 character = 1..5 charcter of the th-parameter name

the corresponding errors are build by puuting 'e' in front of the

coded parameter name and truncating the result to 8 chars.

See -\/-\textgreater{} plot noparplo to get a plot with a noncrowded
parameter part

those parameters may be used in expressions.

OPTION: map

-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-

if -\/-\textgreater{} fit map writes files map.xy and map.ssq that
contain

the landscape of ssq vs paramateters (max. no of free pars.=3)

The parameters varied are those with nonzero fitscale.

The stepwidth used is fitscale/div (div may be given as parameter

in the command line, default is 20).

Map must be followed by the number of grid points in each direction.

Use ssq.gli to display the resulting files (2D).

If map is given NO fitting will be performed !

The commandline must be finished by the parameter: go

yfitform enter a formula that may be used as fitting function by

invoking eval as theory. the formula is entered as

a pseudo-resline after a ;

yfitform ;p(1)+xx*p(2)+xx*xx*p(3)

where xx is the independent variable and p(i) are the

parameters as given with eval.

! this type of function evaluation is quite inefficient !

however it may be used for a quick check of simple ideas

without changing the program code.

help with the \textless{}help\textgreater{}-command you get these
information or, if you use

\textless{}help\textgreater{} \textless{}command\textgreater{}, you will
get specific information about one

datreat-command.

in \textless{}in\textgreater{} filename

this command allows you to read a datarecord from disk. the data

must be stored in the following format:

(the uppercaes words are keywords !)

line 1: arbitrary comments

line 2: filename y-label vs x-label scancode

line 3: \{must be empty !\}

line 4: parameters

line 5: par1 value1

.

.

line x: parxy valuexy \{10 is the maximum number of parameters\}

\{let's call it line 10\}

line 11: \{must be empty !\}

line 12: values

line 13ff.: {[}x{]} x-value {[}y{]} y-value {[}e{]} error

or x x-value1 x-value2 x-value3 ...

y y-value1 y-value2 y-value3 ...

e error1 error2 error3 .....

\{always one line x-values and one line y-values !\}

line y: \{must be empty !\}

line y+1: \#eod

there are two files that can be linked to your data by the

get-command of the xeditor: file kopf must be linked to the

beginning of your data and provides the header, file eod gives

an empty line and the \#eod-keyword.

invers \textless{}invers\textgreater{} {[}bkgr background{]}

this command converts the first selected datarecord to

i-1 vs q**2 - format. the original data must be i vs q.

with bkgr you can subtract a constant background-level

before inverting.

iout \textless{}iout\textgreater{} {[}number{]}

with \textless{}iout\textgreater{} you can set your output-level.

m \textless{}m\textgreater{} est\_mid x1 x2

the \textless{}m\textgreater{}-command generates a mirror-image of a
selected data-

record (it must be selected before !).

in est\_mid you estimate the center-x.

with x1 and x2 you specifiy the range that shall be used to

determine the center.

numorplos \textless{}numorpls\textgreater{} offset

this command should only be used in the beginning of a session,

it sets the offset, that is added to the scan-code, when any

operation is performed by the program.

the default-value is 10000. this means, that usually you can

identify your data as follows:

00xxx : raw-data i(ntensity) vs kanal

10xxx : mirror-data dto. \{see \textless{}m\textgreater{}\}

20xxx : symmetric-data sym-i vs kanal \{see
\textless{}sym\textgreater{}\}

30xxx : converted-data i vs q \{see \textless{}qc\textgreater{}\}

40xxx : "inverted"-data i-1 vs q**2 \{see
\textless{}invers\textgreater{}\}

-xxxxx : fit-curve \{see \textless{}fit\textgreater{}\}

to keap your head clear of garbage, you should use the cycle-

numbers of your experiment as scan-numbers. to distinguish

"horizontal"-data from "vertical"-data use 1xxx for horizontal

and 0xxx for vertical data. if this definition becomes popular,

it will be easier to exchange data with other users.

p \textless{}p\textgreater{} {[}sc scan1 {[}scan2 ...{]}{]}

*{[}fsc fitscan1 {[}fitscan2 ...{]}{]}*

{[}xmin minimum\_x\_value{]}

{[}xmax maximum\_x\_value{]}

{[}ymin min\_y{]} {[}ymax max\_y{]}

{[}framx length\_of\_x\_axes{]} {[}framy length\_of\_y\_axes{]}

{[}frlux beginning\_of\_x\_axes{]} {[}frluy beg\_of\_y\_axes{]}

{[}symb symbol1 {[}symbol2 ...{]}{]}

{[}icolo color1 {[}color2 ...{]}{]}

{[}o... option-specifier{]}

{[}fitflag{]}

{[}textflag{]}

{[}show\_parameter\_flag{]}

{[}txsize textsize{]}

{[}font fontnumber{]}

{[}legsize legend\_size{]}

{[}legx relative\_x\_position\_of\_legend{]}

{[}legy rel\_y\_pos\_of\_legend{]}

{[}errplo / noerrplo{]}

{[}parplo / noparplo{]}

{[}log\_x / lin\_x{]}

{[}log\_y / lin\_y{]}

the \textless{}plot\textgreater{}-command is one of the most powerful
commands of this

program. once you know how to use the parameters, you can do

nearly every plot you like. after execution you are asked,

whether you want to print the plot elsewhere.

with sc you can select certain data-records as usually.

fsc may be used to select several fit-curves. if you performed

a fitting, this fit is automatically selected. after selecting

other curves by sc or a \textless{}sel\textgreater{}-command, you have
to specify the

fit-curves that shall be plotted. this is especially useful,

when you want to have different fits for different intervals.

attention: you must give the corresponding positive scan-number

to select a fit! this allows it to select fit-curves automati-

cally in a makro.

choose the borders of your plot with xmin, xmax, ymin and ymax.

the frxxx-parameters can be used to size and locate your plot.

symb chooses the symbols that are used to represent a data-point

in the plot. the first number will be used for the first selec-

ted item, the second for the second, ... . for detailed infor-

mation see the gr-software-handbook or (if you read a print of

this guide to datreat) the appendix.

icolo chooses the colors for your plot. only selected data-

records can be colored. the codes are:

0 black (default for all curves)

1 red

2 blue

3 green

4 purple

5 yellow

6 zyan.

o... specifies the options for your axes. for detailed informa-

tion see the gr-software-handbook (graxs-subprogram). the format

is (example): ox x=1 \{shows x-axes below your graph\}.

\{2 puts the axes above and 3 on both sides. -1/-2/-3 shows a

grid\}

fitflag can be fits or nofits and says if fit-curves are to be

presented.

textflag is text or notext and is used to show title and legend

or not.

show\_parameter\_flag is parplo or noparplo and determines whether

(when text is set) all parameters are shown or only the legend.

txsize determines the size of the text on the axes and the

title.

with font you can choose a graphic font. detailed information is

again given in the gr-software-handbook or in the appendix.

legsize sets the size in which the legend-text and parameters

are plotted.

legx and legy can be used to move the legend elsewhere, when

it would cover your data (or if you prefer a different place).

\{if you want to set plot-parameters only, use
\textless{}plot0\textgreater{}\}

errplo / noerrplo activates/desactivates plotting of

errorbars

parplo / noparplo may be use to switch (on/off) the writing

of the parameters associated to each file at the right border

of the plot. If noparplo is in effect one may select a number

of parameters that is plotted anyway by specifying the name

of those parameters in the plot command (volatile).

log\_x, log\_y yields log-scaling of the x/y-axes. Use

lin\_x, lin\_y to go back to linear scaling.

p0 \textless{}p0\textgreater{} {[}... see p(lot) ... {]}

\textless{}plot0\textgreater{} sets parameters for following plots, but
does not plot

anything. this command is especially useful for defining an

initial setting according to your taste. the parameters are

described in \textless{}p(lot)\textgreater{}.

purge \textless{}purge\textgreater{} {[}dir\#1 {[}dir\#2 ...{]}{]}
\textbar{} {[}all{]}

this command is used to delete datarecords from your directory.

use the \textless{}dir\textgreater{}-command before to get the right
numbers.

all selections will be removed.

qc \textless{}qc\textgreater{}

\textless{}qc\textgreater{} converts the symmetric i vs kanal -data into
i vs q. this

command operates on the first selected item.

q \textless{}q\textgreater{}

leaves the program. if you send plots to external printing-media

it may be useful to quit datreat once a while, because the plot

is only started when the program is quitted.

sel \textless{}sel\textgreater{} nadd1 nadd2 ... {[}fit+{]}

\textless{}sel\textgreater{} add nadd3 nadd4 ...

\textless{}sel\textgreater{} sc scan1 {[}scan2 ...{]}

\textless{}sel\textgreater{} sc+ scan-n+1 ...

\textless{}sel\textgreater{} fits

the \textless{}sel\textgreater{}-command can be used to select certain
datarecords for

further operations. The same effect is achieved when using sc

as keyword in several commands.

If direct addressing is used, the OPTION add allows to keep NEW

the previous selction and to add further recods to the selection.

when an operation generates a new datarecord this new record is

automatically selected.

Option: fit+ adds the corresponding fits to the selection NEW

given as list of sequence numbers NEW

parameter sc selects scans according to their numors

sc+ adds numor selections to present list

only a number list selects entries according to their

sequence number in the dir-list

OPTION fits searches for old fitted items and selects them

as fits of the selected items if the numors do match.

sym \textless{}sym\textgreater{}

this command calculates the mean-values of the data on the left

and right side of the center and creates a new datarecord with

only one side.

spline \textless{}spline\textgreater{} {[}auto{]}/{[}noauto{]} {[}nneu
nneu{]} {[}smpar smpar{]}

spline approximation of scattered data on the selected scan.

the smoothing parameter smpar is automatically determined if

the option auto is given. otherwise (noauto) smpar must be

specified (by try and error, look at the plot!). smpar will

influence the degree of smoothing. nneu specifies the number

of points (density) the smoothed synthetic new scan should

get within the x-range of the original scan.

the spline polynomial coefficients of the last spline call

are stored in an internal common block for subsequent use,

i.e. in des or fft.

des des {[}qmax qmax{]} {[}nneu nneu{]}

infinite slit height desmearing up to a q-value of qmax.

the new dataset will contain nneu points.

the data to be desmeared must be splined immediately before

des is invoked.

thc \textless{}thc\textgreater{} {[}n{]} n {[}x{[}c{]}1 x1{]}
{[}x{[}c{]}2 x2{]} {[}auto{]} {[}convolute{]} {[}off{]}

with \textless{}thc\textgreater{} you can recalculate fit-data. n is the
number

of points that are used for calculation; 0 means: take value

from last fit.

NEGATIVE n will cause an even distribution x-values on a

logarithmic scale, if x1=0 or x2=0 or x1\textgreater{}=x2 this option

is ignored.

if auto is given x1 and x2 values are ignored and all data are

respected in the calcul. the next time x1 or x2 is given again

a corresponding limit is again established.

if convolute the external routine datconv is taken to

convolute the calculated data before leaving thc.

the number of points and range before convolution is

specified by n, xc1 and xc2 ( instead of n, x1 and x2 ! ).

the result gets the x-values of the selected template(s).

the x-ranges before and after convolution may be different

depending on the transformation that is implicit in the

convolution kernel (e.g. q-values -\/-\/-\textgreater{} scattering
angles).

usually x belongs is a physical varaible before and an

experiment varaiable after convolution. xc1/2 refer to the

physical variable range. the selected item has to

be in experiment space.

all convolution settings are also valid during fit.

convolution is valid until convolution off is specified.

any parameters needed to specify the convolution kernel

are to be given as parameters in the selected data-item,

they are extracted by datconv using the getpar routine.

theos \textless{}theos\textgreater{}

if you want to know what theories are available in your version

of datreat, simply type theos and you will see.

tit \textless{}tit\textgreater{} titlestring

with the \textless{}title\textgreater{}-command you can define a title
that is dis-

played with your plots if the text-option is set.

rename \textless{}rename\textgreater{} {[}xaxis
\textless{}new-string\textgreater{}{]} {[}yaxis
\textless{}new-string\textgreater{}{]} {[}name new{]}

the xaxis and/or yaxis and/or id-names of all selected items

are replaced by the strings given here.

putpar \textless{}putpar\textgreater{} \textless{}parname\textgreater{}
\textless{}value\textgreater{}

a parameter with name \textless{}parname\textgreater{} will be created
and set

to the value \textless{}value\textgreater{} in all selected items. if
the

parameter already exists, its value is updated.

z \textless{}z\textgreater{}

this command is used to clear (\textless{}zero\textgreater{}) the
buffer. no datare-

cords can be selected afterwards. the
\textless{}dir\textgreater{}-command will show

an empty list.

makro \{see general information also\}

there are some standard-makros which simplify the use of this

program:

doit filename scancode loads the specified data-record

and does everything up to the

q-conversion automatically.

cth calls the xeditor to edit the

last activated theorie-para-

meters and then activates this

theorie.

plnorm sets standard values for plot

i vs q.

plzimm sets standard values for plot

i-1 vs q**2.

set set/create a user-defined variable.

usage is set \textless{}name\textgreater{}
\textless{}value\textgreater{} {[} \textless{}name\textgreater{}
\textless{}value\textgreater{} ...

variables may be listed by the command: vars?

some commands transfer their parameters to the

uservariable-stack, so that these variables can

be referred to.

clr remove user-defined variables

usage clr all removes all uservariables.

clr \textless{}name1\textgreater{} \textless{}name2\textgreater{} ...
\textless{}namex\textgreater{} removes the

variables with \textless{}name1\textgreater{} ..
\textless{}namex\textgreater{}

setdeg set angle-units to degree for the commandline

trigonometric functions.

setrad set angle-units to rad for the commandline

trigonometric functions.

?? display the value of a formula.

?? \textless{}expression\textgreater{}

displays the evaluated value of \textless{}expression\textgreater{}

if if-construct for makros

usage if \textless{}expression1\textgreater{} =
\textless{}expression2\textgreater{} then
\textless{}commandline\textgreater{}

or if \textless{}expression1\textgreater{} \textgreater{}
\textless{}expression2\textgreater{} then
\textless{}commandline\textgreater{}

or if \textless{}expression1\textgreater{} \textless{}
\textless{}expression2\textgreater{} then
\textless{}commandline\textgreater{}

or if \textless{}expression1\textgreater{} \textless{}=
\textless{}expression2\textgreater{} then
\textless{}commandline\textgreater{}

or if \textless{}expression1\textgreater{} \textgreater{}=
\textless{}expression2\textgreater{} then
\textless{}commandline\textgreater{}

or if \textless{}expression1\textgreater{} \textless{}\textgreater{}
\textless{}expression2\textgreater{} then
\textless{}commandline\textgreater{}

goto goto construct for makros

usage goto :label

the label :label has to start with ':', the

line containing the label may not contain any

other commands.

vars lists all userdefined variables

ref internal data may be referenced within expressions.

xx -\/-\textgreater{} current x-value (funfun)

yy -\/-\textgreater{} current y-value (funfun)

xv(i,j) -\/-\textgreater{} j-th x-value of i-th databuffer

yv(i,j) -\/-\textgreater{} j-th y-value of i-th databuffer

ye(i,j) -\/-\textgreater{} j-th yerror-value of i-th databuffer

sumx(i,j1,j2)

sumy(i,j1,j2) -\/-\textgreater{} sums

sel -\/-\textgreater{} first selected buffer

nbuf -\/-\textgreater{} number of loaded buffers

maxx

maxy

minx

miny -\/-\textgreater{} max and min of the first selected curve

iout -\/-\textgreater{} current outputlevel

\textless{}parname\textgreater{} -\/-\textgreater{} parametervalue of
selected curve

\textless{}parname(n)-\textgreater{} parametervalue curve n

\textless{}fitpar\textgreater{} -\/-\textgreater{} name of fitparameter,
only the

last of equally named fit-parameters

is accessible

th\_par(ip,it) -\/-\textgreater{} value of the ip-th parameter of the
NEW

it-th activated theory

th\_err(ip,it) -\/-\textgreater{} error of the ip-th parameter of the
NEW

it-th activated theory

Michael Monkenbusch,

IFF, Forschungszentrum Juelich, D-52428 Juelich

Tel.: +49-2461-61-4314/2799

Fax.: +49-2461-61-2610

E-m.: m.monkenbusch@fz-juelich.de

new

sel all {[}parna{]} {[}val{]} band {[}val{]}

sel next {[}parna{]} \ldots{}..

sel add +\ldots{}..

theory kohl with gaussian resolution parameters for folding

(makros resit \ldots{})

theor

\hypertarget{bss-data-converter}{%
\section{BSS-Data Converter}\label{bss-data-converter}}

convert\_dat2.f

\hypertarget{new-development-thinktank}{%
\section{NEW DEVELOPMENT: Thinktank}\label{new-development-thinktank}}

create a new entry in the theory header line (same level as `multiply')
to specify a parameter range in which the theory is evaluated, outside a
zero contribution is added. The parameter value stems from the parameter
block of the actual data-record (iadda).

E.g.: theory XYZ {[}multiply{]} {[}range
\textless{}parname\textgreater{} \textless{}val-min\textgreater{}
\textless{}val-max\textgreater{}{]}

default: full range.

Programming Interface by multiple include files/preprocessor (see McStas
as example).

Intro-section

Closing-section

???

Preprocessor/ vs Description

\end{document}
